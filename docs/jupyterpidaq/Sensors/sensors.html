<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 10.0.4"/>
    <title>jupyterpidaq.Sensors.sensors API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc section{margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;cursor:pointer;}.pdoc details > summary:focus{outline:0;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:2.5rem;}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>            <a class="pdoc-button module-list-button" href="../Sensors.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                &nbsp;jupyterpidaq.Sensors</a>

<a href="https://jupyterphysscilab.github.io/JupyterPiDAQ/">            <img src="docs/DAQmenu.png" class="logo" alt="project logo"/>
</a>
            <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                   pattern=".+" required>



        <h2>API Documentation</h2>
            <ul class="memberlist">
            <li>
                    <a class="function" href="#to_reasonable_significant_figures">to_reasonable_significant_figures</a>
            </li>
            <li>
                    <a class="function" href="#to_reasonable_significant_figures_fast">to_reasonable_significant_figures_fast</a>
            </li>
            <li>
                    <a class="function" href="#listSensors">listSensors</a>
            </li>
            <li>
                    <a class="class" href="#RawAtoD">RawAtoD</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RawAtoD.__init__">RawAtoD</a>
                        </li>
                        <li>
                                <a class="function" href="#RawAtoD.getname">getname</a>
                        </li>
                        <li>
                                <a class="function" href="#RawAtoD.getvendor">getvendor</a>
                        </li>
                        <li>
                                <a class="function" href="#RawAtoD.getunits">getunits</a>
                        </li>
                        <li>
                                <a class="function" href="#RawAtoD.V">V</a>
                        </li>
                        <li>
                                <a class="function" href="#RawAtoD.mV">mV</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#BuiltInThermistor">BuiltInThermistor</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#BuiltInThermistor.__init__">BuiltInThermistor</a>
                        </li>
                        <li>
                                <a class="function" href="#BuiltInThermistor.K">K</a>
                        </li>
                        <li>
                                <a class="function" href="#BuiltInThermistor.C">C</a>
                        </li>
                        <li>
                                <a class="function" href="#BuiltInThermistor.F">F</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#VernierSSTemp">VernierSSTemp</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#VernierSSTemp.__init__">VernierSSTemp</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierSSTemp.K">K</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierSSTemp.C">C</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierSSTemp.F">F</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#VernierGasP">VernierGasP</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#VernierGasP.__init__">VernierGasP</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP.Pa">Pa</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP.kPa">kPa</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP.Bar">Bar</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP.Torr">Torr</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP.mmHg">mmHg</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP.atm">atm</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#VernierGasP_OLD">VernierGasP_OLD</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#VernierGasP_OLD.__init__">VernierGasP_OLD</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP_OLD.Pa">Pa</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP_OLD.kPa">kPa</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP_OLD.Bar">Bar</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP_OLD.Torr">Torr</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP_OLD.mmHg">mmHg</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierGasP_OLD.atm">atm</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#VernierpH">VernierpH</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#VernierpH.__init__">VernierpH</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierpH.pH">pH</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#VernierFlatpH">VernierFlatpH</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#VernierFlatpH.__init__">VernierFlatpH</a>
                        </li>
                        <li>
                                <a class="function" href="#VernierFlatpH.pH">pH</a>
                        </li>
                </ul>

            </li>
    </ul>


            <footer>JupyterPiDAQ v0.7.4.1</footer>

        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../../jupyterpidaq.html">jupyterpidaq</a><wbr>.<a href="./../Sensors.html">Sensors</a><wbr>.sensors    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="c1"># Definitions of known sensors for JupyterPiDAQ</span>
<span class="c1"># By Jonathan Gutow &lt;gutow@uwosh.edu&gt;</span>
<span class="c1"># June 2019</span>
<span class="c1"># license GPL3+</span>

<span class="c1"># class for each sensor and some utility functions</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1">###</span>
<span class="c1"># Private Utility functions. WARNING: behavior may change</span>
<span class="c1">###</span>

<span class="c1"># Unit conversions</span>

<span class="k">def</span> <span class="nf">_KtoC</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param K: temperature in K</span>
<span class="sd">    :return: temperature in C</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">K</span> <span class="o">-</span> <span class="mf">273.15</span>


<span class="k">def</span> <span class="nf">_CtoF</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param C: temperature in C</span>
<span class="sd">    :return: temperature in F</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">C</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span> <span class="o">+</span> <span class="mf">32.0</span>


<span class="k">def</span> <span class="nf">_ntc_therm_RtoK</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts resistance of a negative temperature coefficient thermistor to</span>
<span class="sd">    temperature in Kelvin using the</span>
<span class="sd">    Steinhart Hart model.</span>
<span class="sd">    :param R: Resistance in Ohms</span>
<span class="sd">    :param A: Steinhart Hart A coefficient</span>
<span class="sd">    :param B: Steinhart Hart B coefficient</span>
<span class="sd">    :param C: Steinhart Hart C coefficient</span>
<span class="sd">    :return: Temperature in K</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">K</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">+</span> <span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">R</span><span class="p">))</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;K: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">K</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">K</span>


<span class="c1">###</span>
<span class="c1"># End of Private Utility Functions.</span>
<span class="c1">###</span>

<span class="c1">###</span>
<span class="c1"># Public Utility Functions</span>
<span class="c1">###</span>

<span class="c1"># Round values to reflect uncertainty/standard deviation</span>

<span class="k">def</span> <span class="nf">to_reasonable_significant_figures</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">uncertainty</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will return value rounded to a reasonable number of</span>
<span class="sd">    significant figures based on the uncertainty. If you are doing this</span>
<span class="sd">    based on the standard return from the raw voltage or the sensor</span>
<span class="sd">    definitions in this file it is recommend that this be the standard</span>
<span class="sd">    deviation of the average, which will often provide about one more digit</span>
<span class="sd">    than the standard deviation. This will provide a guard digit for further</span>
<span class="sd">    computations.</span>

<span class="sd">    :param float value: the value to be rounded</span>
<span class="sd">    :param float uncertainty: the uncertainty.</span>

<span class="sd">    :returns float:</span>

<span class="sd">    Returns: rounded_value a floating point number.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">decimals</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">uncertainty</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">decimals</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uncertainty</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">uncertainty</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">decimals</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">uncertainty</span><span class="p">)))</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">to_reasonable_significant_figures_fast</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will return values rounded to a reasonable number of</span>
<span class="sd">    significant figures based on the avg_std. This function requires fewer</span>
<span class="sd">    compares so is a little more efficient than calling</span>
<span class="sd">    to_reasonable_significant_figures(value, uncertainty) for avg, std,</span>
<span class="sd">    avg_std separately.</span>

<span class="sd">    :param float avg: the average value</span>
<span class="sd">    :param float std: the standard deviation</span>
<span class="sd">    :param float avg_std: the estimated standard deviation in avg</span>
<span class="sd">    :returns list:</span>

<span class="sd">    Returns: list of rounded values for each [avg, std, avg_std]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">decimals</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">avg_std</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">decimals</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">avg_std</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">avg_std</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">decimals</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">avg_std</span><span class="p">)))</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span>
    <span class="n">avg_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">avg_std</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">avg</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">]</span>


<span class="c1"># Sensor list.</span>
<span class="c1"># TODO: Should be added to when each new sensor class is added.</span>

<span class="k">def</span> <span class="nf">listSensors</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides a list of the sensor classes provided by this file. The list must</span>
<span class="sd">    be manually updated with each new class.</span>
<span class="sd">    :return: list of classnames</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;RawAtoD&#39;</span><span class="p">,</span>
            <span class="s1">&#39;BuiltInThermistor&#39;</span><span class="p">,</span>
            <span class="s1">&#39;VernierSSTemp&#39;</span><span class="p">,</span>
            <span class="s1">&#39;VernierGasP&#39;</span><span class="p">,</span>
            <span class="s1">&#39;VernierGasP_OLD&#39;</span><span class="p">,</span>
            <span class="s1">&#39;VernierpH&#39;</span><span class="p">,</span>
            <span class="s1">&#39;VernierFlatpH&#39;</span>
            <span class="p">]</span>
    <span class="c1"># TODO: extend this list when each new sensor class is added. RawAtoD</span>
    <span class="c1">#  should always be first in the list.</span>


<span class="c1">###</span>
<span class="c1"># Sensor Classes</span>
<span class="c1">#</span>
<span class="c1"># Each class must extend the `Class RawAtoD`. See below:</span>
<span class="c1">###</span>

<span class="k">class</span> <span class="nc">RawAtoD</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the base sensor class which all sensors should extend. See how to</span>
<span class="sd">    do this properly using one of the examples below.</span>
<span class="sd">    This class contains definitions for the raw AtoD return in volts. The</span>
<span class="sd">    digital values are not used as the AtoD may have a builtin pre-amp,</span>
<span class="sd">    so a given digital value has different meanings depending upon the pre-amp</span>
<span class="sd">    setting.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This init should be called first in the init section of any class</span>
<span class="sd">        extending this class (e.g. `super().__init__(Vdd)`). Then set</span>
<span class="sd">        `self.name` and `self.vendor` to the proper values. Append units</span>
<span class="sd">        specific to the sensor to `self.units`. The parameter Vdd must be</span>
<span class="sd">        supplied upon initialization because the output voltage of some</span>
<span class="sd">        sensors depends on Vdd.</span>

<span class="sd">        :param float Vdd: the voltage supplied to the sensor by the A-to-D</span>
<span class="sd">         board in case the sensor output depends on this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Volts at A-to-D&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;--&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;mV&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">getname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a string name for the sensor</span>
<span class="sd">        :return: string containing the sensor name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">getvendor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a string name for the sensor vendor/manufacturer</span>
<span class="sd">        :return: string containing the vendor/manufacturer name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span>

    <span class="k">def</span> <span class="nf">getunits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides the string names for the available units for this sensor.</span>
<span class="sd">        These string names are also the functions within this class that</span>
<span class="sd">        return the measurement in those units.</span>
<span class="sd">        :return: units a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>

    <span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It is not really necessary to call this function because it just</span>
<span class="sd">        returns the same values that are passed to it.</span>
<span class="sd">        It is provided for consistency with the way sensors units are defined.</span>
<span class="sd">        :param v_avg: v_avg: average voltage from A-to-D</span>
<span class="sd">        :param v_std: standard deviation of the A-to-D measurements</span>
<span class="sd">        :param avg_std: estimate of the standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return: [v_avg, v_std, avg_std]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span>

    <span class="k">def</span> <span class="nf">mV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the raw AtoD voltage to mV.</span>
<span class="sd">        :param v_avg: v_avg: average voltage from A-to-D</span>
<span class="sd">        :param v_std: standard deviation of the A-to-D measurements</span>
<span class="sd">        :param avg_std: estimate of the standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return: [v_avg, v_std, avg_std] converted to mV</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">v_avg</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">v_std</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">avg_std</span>


<span class="k">class</span> <span class="nc">BuiltInThermistor</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for builtin thermistor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Built-in Thermistor&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;KNARCO&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gains</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="c1"># print(&#39;Done initializing builtinthermistor class.&#39;)</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the string</span>
    <span class="c1"># used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in K. It is assumed that the distribution is</span>
<span class="sd">        symmetric guassian even in K. This may not be true, but still gives</span>
<span class="sd">        a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param v_avg: average voltage from sensor.</span>
<span class="sd">        :param v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: list [K_avg, K_std, K_avg_std]</span>
<span class="sd">         [average temperature in K,</span>
<span class="sd">         standard deviation of temperature in K,</span>
<span class="sd">         estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Correct values based on measured reference voltage</span>
        <span class="n">v_avg</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">v_std</span> <span class="o">=</span> <span class="n">v_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">avg_std</span> <span class="o">=</span> <span class="n">avg_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="c1"># v_avg to K</span>
        <span class="n">K_avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_avg</span><span class="p">)</span>
        <span class="c1"># standard deviation of temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">v_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">v_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="c1"># estimated standard deviation of the average temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">avg_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">avg_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_avg_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="k">return</span> <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>

    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg C. It is assumed that the distribution</span>
<span class="sd">        is symmetric guassian even in deg C. This may not be true, but still</span>
<span class="sd">        gives a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param v_avg: average voltage from sensor.</span>
<span class="sd">        :param v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: list [C_avg, C_std, C_avg_std]</span>
<span class="sd">         [average temperature in C, standard deviation of temperature in C,</span>
<span class="sd">            estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">C_avg</span> <span class="o">=</span> <span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">C_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>

    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg F. It is assumed that the distribution</span>
<span class="sd">        is symmetric guassian even in deg F. This may not be true, but still</span>
<span class="sd">        gives a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :returns list:</span>

<span class="sd">        Returns: list [F_avg, F_std, F_avg_std]</span>
<span class="sd">         [average temperature in F, standard deviation of temperature in F,</span>
<span class="sd">         estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">F_avg</span> <span class="o">=</span> <span class="n">_CtoF</span><span class="p">(</span><span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">))</span>
        <span class="n">F_std</span> <span class="o">=</span> <span class="n">K_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="n">F_avg_std</span> <span class="o">=</span> <span class="n">K_avg_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="k">return</span> <span class="n">F_avg</span><span class="p">,</span> <span class="n">F_std</span><span class="p">,</span> <span class="n">F_avg_std</span>

    <span class="k">def</span> <span class="nf">_VtoK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param volts: voltage measurement</span>
<span class="sd">        :return: temperature in K.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Steinhart Hart coefficients for this thermistor</span>
        <span class="n">A</span> <span class="o">=</span> <span class="mf">0.0009667974157916105</span>
        <span class="n">B</span> <span class="o">=</span> <span class="mf">0.00024132572130718138</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">2.077144181533216e-07</span>
        <span class="c1"># Need to stay in sensor range, if get bad voltage throw max or min</span>
        <span class="c1"># possible value alternative for pegging would be to set to 1.649999</span>
        <span class="c1"># which gives &lt; absolute zero.</span>
        <span class="k">if</span> <span class="n">volts</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">volts</span> <span class="o">=</span> <span class="mf">1e-312</span>  <span class="c1"># gets about 0 K</span>
        <span class="k">if</span> <span class="n">volts</span> <span class="o">&gt;=</span> <span class="mf">1.65</span><span class="p">:</span>
            <span class="n">volts</span> <span class="o">=</span> <span class="mf">1.649998411</span>  <span class="c1"># gets very high T in K</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">*</span> <span class="mf">1.0e4</span> <span class="o">/</span> <span class="n">volts</span> <span class="o">-</span> <span class="mf">2.0e4</span>
        <span class="n">tempK</span> <span class="o">=</span> <span class="n">_ntc_therm_RtoK</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tempK</span>


<span class="k">class</span> <span class="nc">VernierSSTemp</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for Vernier Stainless Steel Temperature</span>
<span class="sd">    Probe. A 20K thermistor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier SS Temperature Probe&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the</span>
    <span class="c1"># string used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in K. It is assumed that the distribution is</span>
<span class="sd">        symmetric guassian even in K. This may not be true, but still gives</span>
<span class="sd">        a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :returns list:</span>

<span class="sd">        Returns list [K_avg, K_std, K_avg_std]</span>
<span class="sd">         [average temperature in K, standard deviation of temperature in K,</span>
<span class="sd">         estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;voltages in: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v_avg</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v_std</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">avg_std</span><span class="p">))</span>
        <span class="c1"># Correct values based on measured reference voltage</span>
        <span class="n">v_avg</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">v_std</span> <span class="o">=</span> <span class="n">v_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">avg_std</span> <span class="o">=</span> <span class="n">avg_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="c1"># v_avg to K</span>
        <span class="n">K_avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_avg</span><span class="p">)</span>
        <span class="c1"># standard deviation of temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">v_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">v_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="c1"># estimated standard deviation of the average temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">avg_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">avg_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_avg_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;K out: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">K_avg</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">K_std</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">K_avg_std</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>

    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg C. It is assumed that the distribution</span>
<span class="sd">        is symmetric guassian even in deg C. This may not be true, but still</span>
<span class="sd">        gives a reasonable estimate of the standard deviation.</span>

<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return tuple:</span>

<span class="sd">        Returns: C_avg, C_std, C_avg_std</span>
<span class="sd">         average temperature in C, standard deviation of temperature in C,</span>
<span class="sd">         estimated standard deviation of the average temperature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">C_avg</span> <span class="o">=</span> <span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">C_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>

    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg F. It is assumed that the</span>
<span class="sd">        distribution is symmetric guassian even in deg F. This may not be</span>
<span class="sd">        true, but still gives a reasonable estimate of the standard</span>
<span class="sd">        deviation.</span>

<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>

<span class="sd">        :return list:</span>

<span class="sd">        Returns: F_avg, F_std, F_avg_std</span>
<span class="sd">         average temperature in F, standard deviation of</span>
<span class="sd">         temperature in F, estimated standard deviation of the average</span>
<span class="sd">         temperature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">F_avg</span> <span class="o">=</span> <span class="n">_CtoF</span><span class="p">(</span><span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">))</span>
        <span class="n">F_std</span> <span class="o">=</span> <span class="n">K_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="n">F_avg_std</span> <span class="o">=</span> <span class="n">K_avg_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="k">return</span> <span class="n">F_avg</span><span class="p">,</span> <span class="n">F_std</span><span class="p">,</span> <span class="n">F_avg_std</span>

    <span class="k">def</span> <span class="nf">_VtoK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param volts: voltage measurement</span>
<span class="sd">        :return: temperature in K.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Steinhart Hart coefficients for this thermistor</span>
        <span class="n">A</span> <span class="o">=</span> <span class="mf">0.00102119</span>
        <span class="n">B</span> <span class="o">=</span> <span class="mf">0.000222468</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">1.33342e-07</span>
        <span class="c1"># Need to stay in sensor range, if get bad voltage throw max or min</span>
        <span class="c1"># possible value alternative for pegging would be to set to 1.649999</span>
        <span class="c1"># which gives &lt; absolute zero.</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="n">volts</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># TODO: fix over and underflow for vernier thermistor sensors.</span>
            <span class="n">volts</span> <span class="o">=</span> <span class="mf">1e-312</span>  <span class="c1"># gets high T</span>
        <span class="k">if</span> <span class="n">volts</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span><span class="p">:</span>
            <span class="n">volts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">-</span> <span class="mf">1e-10</span>  <span class="c1"># gets low T in K</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">volts</span> <span class="o">*</span> <span class="mf">1.5e4</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">-</span> <span class="n">volts</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;volts: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">volts</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; R: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
        <span class="n">tempK</span> <span class="o">=</span> <span class="n">_ntc_therm_RtoK</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tempK</span>


<span class="k">class</span> <span class="nc">VernierGasP</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for Vernier absolute gas pressure</span>
<span class="sd">    sensor, GPS-BTA (post 2011 manufacture).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Absolute Gas Pressure Sensor (New)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier (manufactured after 2011)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;Pa&#39;</span><span class="p">,</span> <span class="s1">&#39;kPa&#39;</span><span class="p">,</span> <span class="s1">&#39;Bar&#39;</span><span class="p">,</span> <span class="s1">&#39;Torr&#39;</span><span class="p">,</span> <span class="s1">&#39;mmHg&#39;</span><span class="p">,</span> <span class="s1">&#39;atm&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the</span>
    <span class="c1"># string used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">Pa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Pascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mi">51710</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="mi">25860</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mi">51710</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mi">51710</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">kPa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in kiloPascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">51.710</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="mf">25.860</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">51.710</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">51.710</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">Bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Bars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">.51710</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="mf">.25860</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">.51710</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">.51710</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">Torr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Torr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">mmHg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in mmHg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Torr</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">atm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in atm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

<span class="k">class</span> <span class="nc">VernierGasP_OLD</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for Vernier absolute gas pressure</span>
<span class="sd">    sensor, GPS-BTA (pre 2011 manufacture. Label does not depict a caliper</span>
<span class="sd">    with the registered trademark symbol).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Absolute Gas Pressure Sensor (New)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier (manufactured after 2011)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;Pa&#39;</span><span class="p">,</span> <span class="s1">&#39;kPa&#39;</span><span class="p">,</span> <span class="s1">&#39;Bar&#39;</span><span class="p">,</span> <span class="s1">&#39;Torr&#39;</span><span class="p">,</span> <span class="s1">&#39;mmHg&#39;</span><span class="p">,</span> <span class="s1">&#39;atm&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the</span>
    <span class="c1"># string used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">Pa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Pascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mi">46480</span> <span class="o">*</span> <span class="n">v_avg</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mi">46480</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mi">46480</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">kPa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in kiloPascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">46.480</span> <span class="o">*</span> <span class="n">v_avg</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">46.480</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">46.480</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">Bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Bars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">.46480</span> <span class="o">*</span> <span class="n">v_avg</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">.46480</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">.46480</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">Torr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Torr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">mmHg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in mmHg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Torr</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">atm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in atm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

<span class="k">class</span> <span class="nc">VernierpH</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for Vernier standard pH</span>
<span class="sd">    sensor, PH-BTA.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Standard pH Sensor&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;pH&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the</span>
    <span class="c1"># string used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">pH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: pH_avg, pH_std, pH_avg_std all in pH units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pH_avg</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.838</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="mf">13.720</span>
        <span class="n">pH_std</span> <span class="o">=</span> <span class="mf">3.838</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">pH_avg_std</span> <span class="o">=</span> <span class="mf">3.838</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">pH_avg</span><span class="p">,</span> <span class="n">pH_std</span><span class="p">,</span> <span class="n">pH_avg_std</span>

<span class="k">class</span> <span class="nc">VernierFlatpH</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for Vernier flat tris-compatible pH</span>
<span class="sd">    sensor, FPH-BTA.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Flat pH Sensor&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;pH&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the</span>
    <span class="c1"># string used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">pH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: pH_avg, pH_std, pH_avg_std all in pH units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pH_avg</span> <span class="o">=</span> <span class="o">-</span><span class="mf">7.78</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="mf">16.34</span>
        <span class="n">pH_std</span> <span class="o">=</span> <span class="mf">7.78</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">pH_avg_std</span> <span class="o">=</span> <span class="mf">7.78</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">pH_avg</span><span class="p">,</span> <span class="n">pH_std</span><span class="p">,</span> <span class="n">pH_avg_std</span>
</pre></div>

        </details>

            </section>
                <section id="to_reasonable_significant_figures">
                            <div class="attr function"><a class="headerlink" href="#to_reasonable_significant_figures">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_reasonable_significant_figures</span><span class="signature">(value, uncertainty)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">to_reasonable_significant_figures</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">uncertainty</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will return value rounded to a reasonable number of</span>
<span class="sd">    significant figures based on the uncertainty. If you are doing this</span>
<span class="sd">    based on the standard return from the raw voltage or the sensor</span>
<span class="sd">    definitions in this file it is recommend that this be the standard</span>
<span class="sd">    deviation of the average, which will often provide about one more digit</span>
<span class="sd">    than the standard deviation. This will provide a guard digit for further</span>
<span class="sd">    computations.</span>

<span class="sd">    :param float value: the value to be rounded</span>
<span class="sd">    :param float uncertainty: the uncertainty.</span>

<span class="sd">    :returns float:</span>

<span class="sd">    Returns: rounded_value a floating point number.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">decimals</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">uncertainty</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">decimals</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uncertainty</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">uncertainty</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">decimals</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">uncertainty</span><span class="p">)))</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function will return value rounded to a reasonable number of
significant figures based on the uncertainty. If you are doing this
based on the standard return from the raw voltage or the sensor
definitions in this file it is recommend that this be the standard
deviation of the average, which will often provide about one more digit
than the standard deviation. This will provide a guard digit for further
computations.</p>

<p>:param float value: the value to be rounded
:param float uncertainty: the uncertainty.</p>

<p>:returns float:</p>

<p>Returns: rounded_value a floating point number.</p>
</div>


                </section>
                <section id="to_reasonable_significant_figures_fast">
                            <div class="attr function"><a class="headerlink" href="#to_reasonable_significant_figures_fast">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">to_reasonable_significant_figures_fast</span><span class="signature">(avg, std, avg_std)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">to_reasonable_significant_figures_fast</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will return values rounded to a reasonable number of</span>
<span class="sd">    significant figures based on the avg_std. This function requires fewer</span>
<span class="sd">    compares so is a little more efficient than calling</span>
<span class="sd">    to_reasonable_significant_figures(value, uncertainty) for avg, std,</span>
<span class="sd">    avg_std separately.</span>

<span class="sd">    :param float avg: the average value</span>
<span class="sd">    :param float std: the standard deviation</span>
<span class="sd">    :param float avg_std: the estimated standard deviation in avg</span>
<span class="sd">    :returns list:</span>

<span class="sd">    Returns: list of rounded values for each [avg, std, avg_std]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">decimals</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">avg_std</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">decimals</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">avg_std</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">avg_std</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">decimals</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">avg_std</span><span class="p">)))</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span>
    <span class="n">avg_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">avg_std</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">avg</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function will return values rounded to a reasonable number of
significant figures based on the avg_std. This function requires fewer
compares so is a little more efficient than calling
to_reasonable_significant_figures(value, uncertainty) for avg, std,
avg_std separately.</p>

<p>:param float avg: the average value
:param float std: the standard deviation
:param float avg_std: the estimated standard deviation in avg
:returns list:</p>

<p>Returns: list of rounded values for each [avg, std, avg_std]</p>
</div>


                </section>
                <section id="listSensors">
                            <div class="attr function"><a class="headerlink" href="#listSensors">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">listSensors</span><span class="signature">()</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">def</span> <span class="nf">listSensors</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides a list of the sensor classes provided by this file. The list must</span>
<span class="sd">    be manually updated with each new class.</span>
<span class="sd">    :return: list of classnames</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;RawAtoD&#39;</span><span class="p">,</span>
            <span class="s1">&#39;BuiltInThermistor&#39;</span><span class="p">,</span>
            <span class="s1">&#39;VernierSSTemp&#39;</span><span class="p">,</span>
            <span class="s1">&#39;VernierGasP&#39;</span><span class="p">,</span>
            <span class="s1">&#39;VernierGasP_OLD&#39;</span><span class="p">,</span>
            <span class="s1">&#39;VernierpH&#39;</span><span class="p">,</span>
            <span class="s1">&#39;VernierFlatpH&#39;</span>
            <span class="p">]</span>
    <span class="c1"># TODO: extend this list when each new sensor class is added. RawAtoD</span>
    <span class="c1">#  should always be first in the list.</span>
</pre></div>

        </details>

            <div class="docstring"><p>Provides a list of the sensor classes provided by this file. The list must
be manually updated with each new class.
:return: list of classnames</p>
</div>


                </section>
                <section id="RawAtoD">
                                <div class="attr class">
        <a class="headerlink" href="#RawAtoD">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RawAtoD</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RawAtoD</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the base sensor class which all sensors should extend. See how to</span>
<span class="sd">    do this properly using one of the examples below.</span>
<span class="sd">    This class contains definitions for the raw AtoD return in volts. The</span>
<span class="sd">    digital values are not used as the AtoD may have a builtin pre-amp,</span>
<span class="sd">    so a given digital value has different meanings depending upon the pre-amp</span>
<span class="sd">    setting.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This init should be called first in the init section of any class</span>
<span class="sd">        extending this class (e.g. `super().__init__(Vdd)`). Then set</span>
<span class="sd">        `self.name` and `self.vendor` to the proper values. Append units</span>
<span class="sd">        specific to the sensor to `self.units`. The parameter Vdd must be</span>
<span class="sd">        supplied upon initialization because the output voltage of some</span>
<span class="sd">        sensors depends on Vdd.</span>

<span class="sd">        :param float Vdd: the voltage supplied to the sensor by the A-to-D</span>
<span class="sd">         board in case the sensor output depends on this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Volts at A-to-D&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;--&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;mV&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">getname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a string name for the sensor</span>
<span class="sd">        :return: string containing the sensor name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">getvendor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a string name for the sensor vendor/manufacturer</span>
<span class="sd">        :return: string containing the vendor/manufacturer name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span>

    <span class="k">def</span> <span class="nf">getunits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides the string names for the available units for this sensor.</span>
<span class="sd">        These string names are also the functions within this class that</span>
<span class="sd">        return the measurement in those units.</span>
<span class="sd">        :return: units a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>

    <span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It is not really necessary to call this function because it just</span>
<span class="sd">        returns the same values that are passed to it.</span>
<span class="sd">        It is provided for consistency with the way sensors units are defined.</span>
<span class="sd">        :param v_avg: v_avg: average voltage from A-to-D</span>
<span class="sd">        :param v_std: standard deviation of the A-to-D measurements</span>
<span class="sd">        :param avg_std: estimate of the standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return: [v_avg, v_std, avg_std]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span>

    <span class="k">def</span> <span class="nf">mV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the raw AtoD voltage to mV.</span>
<span class="sd">        :param v_avg: v_avg: average voltage from A-to-D</span>
<span class="sd">        :param v_std: standard deviation of the A-to-D measurements</span>
<span class="sd">        :param avg_std: estimate of the standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return: [v_avg, v_std, avg_std] converted to mV</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">v_avg</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">v_std</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is the base sensor class which all sensors should extend. See how to
do this properly using one of the examples below.
This class contains definitions for the raw AtoD return in volts. The
digital values are not used as the AtoD may have a builtin pre-amp,
so a given digital value has different meanings depending upon the pre-amp
setting.</p>
</div>


                            <div id="RawAtoD.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RawAtoD.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RawAtoD</span><span class="signature">(Vdd)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This init should be called first in the init section of any class</span>
<span class="sd">        extending this class (e.g. `super().__init__(Vdd)`). Then set</span>
<span class="sd">        `self.name` and `self.vendor` to the proper values. Append units</span>
<span class="sd">        specific to the sensor to `self.units`. The parameter Vdd must be</span>
<span class="sd">        supplied upon initialization because the output voltage of some</span>
<span class="sd">        sensors depends on Vdd.</span>

<span class="sd">        :param float Vdd: the voltage supplied to the sensor by the A-to-D</span>
<span class="sd">         board in case the sensor output depends on this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Volts at A-to-D&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;--&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;mV&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>This init should be called first in the init section of any class
extending this class (e.g. <code>super().__init__(Vdd)</code>). Then set
<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units
specific to the sensor to <code>self.units</code>. The parameter Vdd must be
supplied upon initialization because the output voltage of some
sensors depends on Vdd.</p>

<p>:param float Vdd: the voltage supplied to the sensor by the A-to-D
 board in case the sensor output depends on this.</p>
</div>


                            </div>
                            <div id="RawAtoD.getname" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RawAtoD.getname">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">getname</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">getname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a string name for the sensor</span>
<span class="sd">        :return: string containing the sensor name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</pre></div>

        </details>

            <div class="docstring"><p>Provides a string name for the sensor
:return: string containing the sensor name</p>
</div>


                            </div>
                            <div id="RawAtoD.getvendor" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RawAtoD.getvendor">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">getvendor</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">getvendor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a string name for the sensor vendor/manufacturer</span>
<span class="sd">        :return: string containing the vendor/manufacturer name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span>
</pre></div>

        </details>

            <div class="docstring"><p>Provides a string name for the sensor vendor/manufacturer
:return: string containing the vendor/manufacturer name</p>
</div>


                            </div>
                            <div id="RawAtoD.getunits" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RawAtoD.getunits">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">getunits</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">getunits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides the string names for the available units for this sensor.</span>
<span class="sd">        These string names are also the functions within this class that</span>
<span class="sd">        return the measurement in those units.</span>
<span class="sd">        :return: units a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>
</pre></div>

        </details>

            <div class="docstring"><p>Provides the string names for the available units for this sensor.
These string names are also the functions within this class that
return the measurement in those units.
:return: units a list of strings.</p>
</div>


                            </div>
                            <div id="RawAtoD.V" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RawAtoD.V">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">V</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It is not really necessary to call this function because it just</span>
<span class="sd">        returns the same values that are passed to it.</span>
<span class="sd">        It is provided for consistency with the way sensors units are defined.</span>
<span class="sd">        :param v_avg: v_avg: average voltage from A-to-D</span>
<span class="sd">        :param v_std: standard deviation of the A-to-D measurements</span>
<span class="sd">        :param avg_std: estimate of the standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return: [v_avg, v_std, avg_std]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>It is not really necessary to call this function because it just
returns the same values that are passed to it.
It is provided for consistency with the way sensors units are defined.
:param v_avg: v_avg: average voltage from A-to-D
:param v_std: standard deviation of the A-to-D measurements
:param avg_std: estimate of the standard deviation of v_avg
:param float avg_vdd: simultaneously measured average Vdd.
:return: [v_avg, v_std, avg_std]</p>
</div>


                            </div>
                            <div id="RawAtoD.mV" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RawAtoD.mV">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">mV</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">mV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the raw AtoD voltage to mV.</span>
<span class="sd">        :param v_avg: v_avg: average voltage from A-to-D</span>
<span class="sd">        :param v_std: standard deviation of the A-to-D measurements</span>
<span class="sd">        :param avg_std: estimate of the standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return: [v_avg, v_std, avg_std] converted to mV</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">v_avg</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">v_std</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>Convert the raw AtoD voltage to mV.
:param v_avg: v_avg: average voltage from A-to-D
:param v_std: standard deviation of the A-to-D measurements
:param avg_std: estimate of the standard deviation of v_avg
:param float avg_vdd: simultaneously measured average Vdd.
:return: [v_avg, v_std, avg_std] converted to mV</p>
</div>


                            </div>
                </section>
                <section id="BuiltInThermistor">
                                <div class="attr class">
        <a class="headerlink" href="#BuiltInThermistor">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">BuiltInThermistor</span><wbr>(<span class="base"><a href="#RawAtoD">RawAtoD</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BuiltInThermistor</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for builtin thermistor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Built-in Thermistor&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;KNARCO&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gains</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="c1"># print(&#39;Done initializing builtinthermistor class.&#39;)</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the string</span>
    <span class="c1"># used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in K. It is assumed that the distribution is</span>
<span class="sd">        symmetric guassian even in K. This may not be true, but still gives</span>
<span class="sd">        a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param v_avg: average voltage from sensor.</span>
<span class="sd">        :param v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: list [K_avg, K_std, K_avg_std]</span>
<span class="sd">         [average temperature in K,</span>
<span class="sd">         standard deviation of temperature in K,</span>
<span class="sd">         estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Correct values based on measured reference voltage</span>
        <span class="n">v_avg</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">v_std</span> <span class="o">=</span> <span class="n">v_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">avg_std</span> <span class="o">=</span> <span class="n">avg_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="c1"># v_avg to K</span>
        <span class="n">K_avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_avg</span><span class="p">)</span>
        <span class="c1"># standard deviation of temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">v_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">v_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="c1"># estimated standard deviation of the average temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">avg_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">avg_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_avg_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="k">return</span> <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>

    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg C. It is assumed that the distribution</span>
<span class="sd">        is symmetric guassian even in deg C. This may not be true, but still</span>
<span class="sd">        gives a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param v_avg: average voltage from sensor.</span>
<span class="sd">        :param v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: list [C_avg, C_std, C_avg_std]</span>
<span class="sd">         [average temperature in C, standard deviation of temperature in C,</span>
<span class="sd">            estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">C_avg</span> <span class="o">=</span> <span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">C_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>

    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg F. It is assumed that the distribution</span>
<span class="sd">        is symmetric guassian even in deg F. This may not be true, but still</span>
<span class="sd">        gives a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :returns list:</span>

<span class="sd">        Returns: list [F_avg, F_std, F_avg_std]</span>
<span class="sd">         [average temperature in F, standard deviation of temperature in F,</span>
<span class="sd">         estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">F_avg</span> <span class="o">=</span> <span class="n">_CtoF</span><span class="p">(</span><span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">))</span>
        <span class="n">F_std</span> <span class="o">=</span> <span class="n">K_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="n">F_avg_std</span> <span class="o">=</span> <span class="n">K_avg_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="k">return</span> <span class="n">F_avg</span><span class="p">,</span> <span class="n">F_std</span><span class="p">,</span> <span class="n">F_avg_std</span>

    <span class="k">def</span> <span class="nf">_VtoK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param volts: voltage measurement</span>
<span class="sd">        :return: temperature in K.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Steinhart Hart coefficients for this thermistor</span>
        <span class="n">A</span> <span class="o">=</span> <span class="mf">0.0009667974157916105</span>
        <span class="n">B</span> <span class="o">=</span> <span class="mf">0.00024132572130718138</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">2.077144181533216e-07</span>
        <span class="c1"># Need to stay in sensor range, if get bad voltage throw max or min</span>
        <span class="c1"># possible value alternative for pegging would be to set to 1.649999</span>
        <span class="c1"># which gives &lt; absolute zero.</span>
        <span class="k">if</span> <span class="n">volts</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">volts</span> <span class="o">=</span> <span class="mf">1e-312</span>  <span class="c1"># gets about 0 K</span>
        <span class="k">if</span> <span class="n">volts</span> <span class="o">&gt;=</span> <span class="mf">1.65</span><span class="p">:</span>
            <span class="n">volts</span> <span class="o">=</span> <span class="mf">1.649998411</span>  <span class="c1"># gets very high T in K</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">*</span> <span class="mf">1.0e4</span> <span class="o">/</span> <span class="n">volts</span> <span class="o">-</span> <span class="mf">2.0e4</span>
        <span class="n">tempK</span> <span class="o">=</span> <span class="n">_ntc_therm_RtoK</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tempK</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class contains the definitions for builtin thermistor.</p>
</div>


                            <div id="BuiltInThermistor.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BuiltInThermistor.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">BuiltInThermistor</span><span class="signature">(Vdd)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Built-in Thermistor&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;KNARCO&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gains</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="c1"># print(&#39;Done initializing builtinthermistor class.&#39;)</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>This init should be called first in the init section of any class
extending this class (e.g. <code>super().__init__(Vdd)</code>). Then set
<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units
specific to the sensor to <code>self.units</code>. The parameter Vdd must be
supplied upon initialization because the output voltage of some
sensors depends on Vdd.</p>

<p>:param float Vdd: the voltage supplied to the sensor by the A-to-D
 board in case the sensor output depends on this.</p>
</div>


                            </div>
                            <div id="BuiltInThermistor.K" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BuiltInThermistor.K">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">K</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in K. It is assumed that the distribution is</span>
<span class="sd">        symmetric guassian even in K. This may not be true, but still gives</span>
<span class="sd">        a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param v_avg: average voltage from sensor.</span>
<span class="sd">        :param v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: list [K_avg, K_std, K_avg_std]</span>
<span class="sd">         [average temperature in K,</span>
<span class="sd">         standard deviation of temperature in K,</span>
<span class="sd">         estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Correct values based on measured reference voltage</span>
        <span class="n">v_avg</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">v_std</span> <span class="o">=</span> <span class="n">v_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">avg_std</span> <span class="o">=</span> <span class="n">avg_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="c1"># v_avg to K</span>
        <span class="n">K_avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_avg</span><span class="p">)</span>
        <span class="c1"># standard deviation of temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">v_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">v_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="c1"># estimated standard deviation of the average temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">avg_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">avg_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_avg_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="k">return</span> <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>The returned values are in K. It is assumed that the distribution is
symmetric guassian even in K. This may not be true, but still gives
a reasonable estimate of the standard deviation.
:param v_avg: average voltage from sensor.
:param v_std: standard deviation of voltage from sensor.
:param avg_std: estimated standard deviation of the avg.
:param float avg_vdd: simultaneously measured average Vdd.
:return list:</p>

<p>Returns: list [K_avg, K_std, K_avg_std]
 [average temperature in K,
 standard deviation of temperature in K,
 estimated standard deviation of the average temperature].</p>
</div>


                            </div>
                            <div id="BuiltInThermistor.C" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BuiltInThermistor.C">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">C</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg C. It is assumed that the distribution</span>
<span class="sd">        is symmetric guassian even in deg C. This may not be true, but still</span>
<span class="sd">        gives a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param v_avg: average voltage from sensor.</span>
<span class="sd">        :param v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: list [C_avg, C_std, C_avg_std]</span>
<span class="sd">         [average temperature in C, standard deviation of temperature in C,</span>
<span class="sd">            estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">C_avg</span> <span class="o">=</span> <span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">C_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>The returned values are in deg C. It is assumed that the distribution
is symmetric guassian even in deg C. This may not be true, but still
gives a reasonable estimate of the standard deviation.
:param v_avg: average voltage from sensor.
:param v_std: standard deviation of voltage from sensor.
:param avg_std: estimated standard deviation of the avg.
:param float avg_vdd: simultaneously measured average Vdd.
:return list:</p>

<p>Returns: list [C_avg, C_std, C_avg_std]
 [average temperature in C, standard deviation of temperature in C,
    estimated standard deviation of the average temperature].</p>
</div>


                            </div>
                            <div id="BuiltInThermistor.F" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BuiltInThermistor.F">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">F</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg F. It is assumed that the distribution</span>
<span class="sd">        is symmetric guassian even in deg F. This may not be true, but still</span>
<span class="sd">        gives a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :returns list:</span>

<span class="sd">        Returns: list [F_avg, F_std, F_avg_std]</span>
<span class="sd">         [average temperature in F, standard deviation of temperature in F,</span>
<span class="sd">         estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">F_avg</span> <span class="o">=</span> <span class="n">_CtoF</span><span class="p">(</span><span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">))</span>
        <span class="n">F_std</span> <span class="o">=</span> <span class="n">K_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="n">F_avg_std</span> <span class="o">=</span> <span class="n">K_avg_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="k">return</span> <span class="n">F_avg</span><span class="p">,</span> <span class="n">F_std</span><span class="p">,</span> <span class="n">F_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>The returned values are in deg F. It is assumed that the distribution
is symmetric guassian even in deg F. This may not be true, but still
gives a reasonable estimate of the standard deviation.
:param float v_avg: average voltage from sensor.
:param float v_std: standard deviation of voltage from sensor.
:param float avg_std: estimated standard deviation of the avg.
:param float avg_vdd: simultaneously measured average Vdd.
:returns list:</p>

<p>Returns: list [F_avg, F_std, F_avg_std]
 [average temperature in F, standard deviation of temperature in F,
 estimated standard deviation of the average temperature].</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#RawAtoD">RawAtoD</a></dt>
                                <dd id="BuiltInThermistor.getname" class="function"><a href="#RawAtoD.getname">getname</a></dd>
                <dd id="BuiltInThermistor.getvendor" class="function"><a href="#RawAtoD.getvendor">getvendor</a></dd>
                <dd id="BuiltInThermistor.getunits" class="function"><a href="#RawAtoD.getunits">getunits</a></dd>
                <dd id="BuiltInThermistor.V" class="function"><a href="#RawAtoD.V">V</a></dd>
                <dd id="BuiltInThermistor.mV" class="function"><a href="#RawAtoD.mV">mV</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="VernierSSTemp">
                                <div class="attr class">
        <a class="headerlink" href="#VernierSSTemp">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">VernierSSTemp</span><wbr>(<span class="base"><a href="#RawAtoD">RawAtoD</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">VernierSSTemp</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for Vernier Stainless Steel Temperature</span>
<span class="sd">    Probe. A 20K thermistor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier SS Temperature Probe&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the</span>
    <span class="c1"># string used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in K. It is assumed that the distribution is</span>
<span class="sd">        symmetric guassian even in K. This may not be true, but still gives</span>
<span class="sd">        a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :returns list:</span>

<span class="sd">        Returns list [K_avg, K_std, K_avg_std]</span>
<span class="sd">         [average temperature in K, standard deviation of temperature in K,</span>
<span class="sd">         estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;voltages in: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v_avg</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v_std</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">avg_std</span><span class="p">))</span>
        <span class="c1"># Correct values based on measured reference voltage</span>
        <span class="n">v_avg</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">v_std</span> <span class="o">=</span> <span class="n">v_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">avg_std</span> <span class="o">=</span> <span class="n">avg_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="c1"># v_avg to K</span>
        <span class="n">K_avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_avg</span><span class="p">)</span>
        <span class="c1"># standard deviation of temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">v_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">v_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="c1"># estimated standard deviation of the average temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">avg_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">avg_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_avg_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;K out: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">K_avg</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">K_std</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">K_avg_std</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>

    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg C. It is assumed that the distribution</span>
<span class="sd">        is symmetric guassian even in deg C. This may not be true, but still</span>
<span class="sd">        gives a reasonable estimate of the standard deviation.</span>

<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return tuple:</span>

<span class="sd">        Returns: C_avg, C_std, C_avg_std</span>
<span class="sd">         average temperature in C, standard deviation of temperature in C,</span>
<span class="sd">         estimated standard deviation of the average temperature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">C_avg</span> <span class="o">=</span> <span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">C_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>

    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg F. It is assumed that the</span>
<span class="sd">        distribution is symmetric guassian even in deg F. This may not be</span>
<span class="sd">        true, but still gives a reasonable estimate of the standard</span>
<span class="sd">        deviation.</span>

<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>

<span class="sd">        :return list:</span>

<span class="sd">        Returns: F_avg, F_std, F_avg_std</span>
<span class="sd">         average temperature in F, standard deviation of</span>
<span class="sd">         temperature in F, estimated standard deviation of the average</span>
<span class="sd">         temperature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">F_avg</span> <span class="o">=</span> <span class="n">_CtoF</span><span class="p">(</span><span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">))</span>
        <span class="n">F_std</span> <span class="o">=</span> <span class="n">K_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="n">F_avg_std</span> <span class="o">=</span> <span class="n">K_avg_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="k">return</span> <span class="n">F_avg</span><span class="p">,</span> <span class="n">F_std</span><span class="p">,</span> <span class="n">F_avg_std</span>

    <span class="k">def</span> <span class="nf">_VtoK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param volts: voltage measurement</span>
<span class="sd">        :return: temperature in K.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Steinhart Hart coefficients for this thermistor</span>
        <span class="n">A</span> <span class="o">=</span> <span class="mf">0.00102119</span>
        <span class="n">B</span> <span class="o">=</span> <span class="mf">0.000222468</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">1.33342e-07</span>
        <span class="c1"># Need to stay in sensor range, if get bad voltage throw max or min</span>
        <span class="c1"># possible value alternative for pegging would be to set to 1.649999</span>
        <span class="c1"># which gives &lt; absolute zero.</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="n">volts</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># TODO: fix over and underflow for vernier thermistor sensors.</span>
            <span class="n">volts</span> <span class="o">=</span> <span class="mf">1e-312</span>  <span class="c1"># gets high T</span>
        <span class="k">if</span> <span class="n">volts</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span><span class="p">:</span>
            <span class="n">volts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">-</span> <span class="mf">1e-10</span>  <span class="c1"># gets low T in K</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">volts</span> <span class="o">*</span> <span class="mf">1.5e4</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">-</span> <span class="n">volts</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;volts: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">volts</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; R: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
        <span class="n">tempK</span> <span class="o">=</span> <span class="n">_ntc_therm_RtoK</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tempK</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class contains the definitions for Vernier Stainless Steel Temperature
Probe. A 20K thermistor.</p>
</div>


                            <div id="VernierSSTemp.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierSSTemp.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">VernierSSTemp</span><span class="signature">(Vdd)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier SS Temperature Probe&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>This init should be called first in the init section of any class
extending this class (e.g. <code>super().__init__(Vdd)</code>). Then set
<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units
specific to the sensor to <code>self.units</code>. The parameter Vdd must be
supplied upon initialization because the output voltage of some
sensors depends on Vdd.</p>

<p>:param float Vdd: the voltage supplied to the sensor by the A-to-D
 board in case the sensor output depends on this.</p>
</div>


                            </div>
                            <div id="VernierSSTemp.K" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierSSTemp.K">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">K</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in K. It is assumed that the distribution is</span>
<span class="sd">        symmetric guassian even in K. This may not be true, but still gives</span>
<span class="sd">        a reasonable estimate of the standard deviation.</span>
<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :returns list:</span>

<span class="sd">        Returns list [K_avg, K_std, K_avg_std]</span>
<span class="sd">         [average temperature in K, standard deviation of temperature in K,</span>
<span class="sd">         estimated standard deviation of the average temperature].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;voltages in: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v_avg</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v_std</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">avg_std</span><span class="p">))</span>
        <span class="c1"># Correct values based on measured reference voltage</span>
        <span class="n">v_avg</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">v_std</span> <span class="o">=</span> <span class="n">v_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="n">avg_std</span> <span class="o">=</span> <span class="n">avg_std</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">/</span> <span class="n">avg_vdd</span>
        <span class="c1"># v_avg to K</span>
        <span class="n">K_avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_avg</span><span class="p">)</span>
        <span class="c1"># standard deviation of temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">v_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">v_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="c1"># estimated standard deviation of the average temperature</span>
        <span class="n">v_max</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="n">avg_std</span>
        <span class="n">v_min</span> <span class="o">=</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="n">avg_std</span>
        <span class="n">K_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_min</span><span class="p">)</span>
        <span class="n">K_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VtoK</span><span class="p">(</span><span class="n">v_max</span><span class="p">)</span>
        <span class="n">K_avg_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">K_max</span> <span class="o">-</span> <span class="n">K_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># assuming a symmetric gaussian error even after transform from volts.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;K out: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">K_avg</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">K_std</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">K_avg_std</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>The returned values are in K. It is assumed that the distribution is
symmetric guassian even in K. This may not be true, but still gives
a reasonable estimate of the standard deviation.
:param float v_avg: average voltage from sensor.
:param float v_std: standard deviation of voltage from sensor.
:param float avg_std: estimated standard deviation of the avg.
:param float avg_vdd: simultaneously measured average Vdd.
:returns list:</p>

<p>Returns list [K_avg, K_std, K_avg_std]
 [average temperature in K, standard deviation of temperature in K,
 estimated standard deviation of the average temperature].</p>
</div>


                            </div>
                            <div id="VernierSSTemp.C" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierSSTemp.C">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">C</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg C. It is assumed that the distribution</span>
<span class="sd">        is symmetric guassian even in deg C. This may not be true, but still</span>
<span class="sd">        gives a reasonable estimate of the standard deviation.</span>

<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>
<span class="sd">        :return tuple:</span>

<span class="sd">        Returns: C_avg, C_std, C_avg_std</span>
<span class="sd">         average temperature in C, standard deviation of temperature in C,</span>
<span class="sd">         estimated standard deviation of the average temperature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">C_avg</span> <span class="o">=</span> <span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">C_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>The returned values are in deg C. It is assumed that the distribution
is symmetric guassian even in deg C. This may not be true, but still
gives a reasonable estimate of the standard deviation.</p>

<p>:param float v_avg: average voltage from sensor.
:param float v_std: standard deviation of voltage from sensor.
:param float avg_std: estimated standard deviation of the avg.
:param float avg_vdd: simultaneously measured average Vdd.
:return tuple:</p>

<p>Returns: C_avg, C_std, C_avg_std
 average temperature in C, standard deviation of temperature in C,
 estimated standard deviation of the average temperature.</p>
</div>


                            </div>
                            <div id="VernierSSTemp.F" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierSSTemp.F">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">F</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The returned values are in deg F. It is assumed that the</span>
<span class="sd">        distribution is symmetric guassian even in deg F. This may not be</span>
<span class="sd">        true, but still gives a reasonable estimate of the standard</span>
<span class="sd">        deviation.</span>

<span class="sd">        :param float v_avg: average voltage from sensor.</span>
<span class="sd">        :param float v_std: standard deviation of voltage from sensor.</span>
<span class="sd">        :param float avg_std: estimated standard deviation of the avg.</span>
<span class="sd">        :param float avg_vdd: simultaneously measured average Vdd.</span>

<span class="sd">        :return list:</span>

<span class="sd">        Returns: F_avg, F_std, F_avg_std</span>
<span class="sd">         average temperature in F, standard deviation of</span>
<span class="sd">         temperature in F, estimated standard deviation of the average</span>
<span class="sd">         temperature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K_avg</span><span class="p">,</span> <span class="n">K_std</span><span class="p">,</span> <span class="n">K_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">F_avg</span> <span class="o">=</span> <span class="n">_CtoF</span><span class="p">(</span><span class="n">_KtoC</span><span class="p">(</span><span class="n">K_avg</span><span class="p">))</span>
        <span class="n">F_std</span> <span class="o">=</span> <span class="n">K_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="n">F_avg_std</span> <span class="o">=</span> <span class="n">K_avg_std</span> <span class="o">*</span> <span class="mf">9.0</span> <span class="o">/</span> <span class="mf">5.0</span>
        <span class="k">return</span> <span class="n">F_avg</span><span class="p">,</span> <span class="n">F_std</span><span class="p">,</span> <span class="n">F_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>The returned values are in deg F. It is assumed that the
distribution is symmetric guassian even in deg F. This may not be
true, but still gives a reasonable estimate of the standard
deviation.</p>

<p>:param float v_avg: average voltage from sensor.
:param float v_std: standard deviation of voltage from sensor.
:param float avg_std: estimated standard deviation of the avg.
:param float avg_vdd: simultaneously measured average Vdd.</p>

<p>:return list:</p>

<p>Returns: F_avg, F_std, F_avg_std
 average temperature in F, standard deviation of
 temperature in F, estimated standard deviation of the average
 temperature.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#RawAtoD">RawAtoD</a></dt>
                                <dd id="VernierSSTemp.getname" class="function"><a href="#RawAtoD.getname">getname</a></dd>
                <dd id="VernierSSTemp.getvendor" class="function"><a href="#RawAtoD.getvendor">getvendor</a></dd>
                <dd id="VernierSSTemp.getunits" class="function"><a href="#RawAtoD.getunits">getunits</a></dd>
                <dd id="VernierSSTemp.V" class="function"><a href="#RawAtoD.V">V</a></dd>
                <dd id="VernierSSTemp.mV" class="function"><a href="#RawAtoD.mV">mV</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="VernierGasP">
                                <div class="attr class">
        <a class="headerlink" href="#VernierGasP">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">VernierGasP</span><wbr>(<span class="base"><a href="#RawAtoD">RawAtoD</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">VernierGasP</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for Vernier absolute gas pressure</span>
<span class="sd">    sensor, GPS-BTA (post 2011 manufacture).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Absolute Gas Pressure Sensor (New)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier (manufactured after 2011)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;Pa&#39;</span><span class="p">,</span> <span class="s1">&#39;kPa&#39;</span><span class="p">,</span> <span class="s1">&#39;Bar&#39;</span><span class="p">,</span> <span class="s1">&#39;Torr&#39;</span><span class="p">,</span> <span class="s1">&#39;mmHg&#39;</span><span class="p">,</span> <span class="s1">&#39;atm&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the</span>
    <span class="c1"># string used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">Pa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Pascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mi">51710</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="mi">25860</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mi">51710</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mi">51710</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">kPa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in kiloPascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">51.710</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="mf">25.860</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">51.710</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">51.710</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">Bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Bars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">.51710</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="mf">.25860</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">.51710</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">.51710</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">Torr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Torr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">mmHg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in mmHg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Torr</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">atm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in atm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class contains the definitions for Vernier absolute gas pressure
sensor, GPS-BTA (post 2011 manufacture).</p>
</div>


                            <div id="VernierGasP.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">VernierGasP</span><span class="signature">(Vdd)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Absolute Gas Pressure Sensor (New)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier (manufactured after 2011)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;Pa&#39;</span><span class="p">,</span> <span class="s1">&#39;kPa&#39;</span><span class="p">,</span> <span class="s1">&#39;Bar&#39;</span><span class="p">,</span> <span class="s1">&#39;Torr&#39;</span><span class="p">,</span> <span class="s1">&#39;mmHg&#39;</span><span class="p">,</span> <span class="s1">&#39;atm&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>This init should be called first in the init section of any class
extending this class (e.g. <code>super().__init__(Vdd)</code>). Then set
<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units
specific to the sensor to <code>self.units</code>. The parameter Vdd must be
supplied upon initialization because the output voltage of some
sensors depends on Vdd.</p>

<p>:param float Vdd: the voltage supplied to the sensor by the A-to-D
 board in case the sensor output depends on this.</p>
</div>


                            </div>
                            <div id="VernierGasP.Pa" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP.Pa">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Pa</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Pa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Pascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mi">51710</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="mi">25860</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mi">51710</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mi">51710</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the raw voltage
:param float avg_std: estimated standard deviation of v_avg
:param float avg_vdd: the Vdd measured simultaneously with v_avg (not
used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in Pascals</p>
</div>


                            </div>
                            <div id="VernierGasP.kPa" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP.kPa">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">kPa</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">kPa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in kiloPascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">51.710</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="mf">25.860</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">51.710</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">51.710</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the raw voltage
:param float avg_std: estimated standard deviation of v_avg
:param float avg_vdd: the Vdd measured simultaneously with v_avg (not
used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in kiloPascals</p>
</div>


                            </div>
                            <div id="VernierGasP.Bar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP.Bar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Bar</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Bars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">.51710</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">-</span> <span class="mf">.25860</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">.51710</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">.51710</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the raw voltage
:param float avg_std: estimated standard deviation of v_avg
:param float avg_vdd: the Vdd measured simultaneously with v_avg (not
used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in Bars</p>
</div>


                            </div>
                            <div id="VernierGasP.Torr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP.Torr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Torr</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Torr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Torr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the voltage measurements
:param float avg_std: estimate of the standard deviation of the average
:param float avg_vdd: the Vdd measured simultaneously with v_avg (
not used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in Torr</p>
</div>


                            </div>
                            <div id="VernierGasP.mmHg" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP.mmHg">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">mmHg</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">mmHg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in mmHg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Torr</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the voltage measurements
:param float avg_std: estimate of the standard deviation of the average
:param float avg_vdd: the Vdd measured simultaneously with v_avg (
not used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in mmHg</p>
</div>


                            </div>
                            <div id="VernierGasP.atm" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP.atm">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">atm</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">atm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in atm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the voltage measurements
:param float avg_std: estimate of the standard deviation of the average
:param float avg_vdd: the Vdd measured simultaneously with v_avg (
not used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in atm</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#RawAtoD">RawAtoD</a></dt>
                                <dd id="VernierGasP.getname" class="function"><a href="#RawAtoD.getname">getname</a></dd>
                <dd id="VernierGasP.getvendor" class="function"><a href="#RawAtoD.getvendor">getvendor</a></dd>
                <dd id="VernierGasP.getunits" class="function"><a href="#RawAtoD.getunits">getunits</a></dd>
                <dd id="VernierGasP.V" class="function"><a href="#RawAtoD.V">V</a></dd>
                <dd id="VernierGasP.mV" class="function"><a href="#RawAtoD.mV">mV</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="VernierGasP_OLD">
                                <div class="attr class">
        <a class="headerlink" href="#VernierGasP_OLD">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">VernierGasP_OLD</span><wbr>(<span class="base"><a href="#RawAtoD">RawAtoD</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">VernierGasP_OLD</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for Vernier absolute gas pressure</span>
<span class="sd">    sensor, GPS-BTA (pre 2011 manufacture. Label does not depict a caliper</span>
<span class="sd">    with the registered trademark symbol).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Absolute Gas Pressure Sensor (New)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier (manufactured after 2011)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;Pa&#39;</span><span class="p">,</span> <span class="s1">&#39;kPa&#39;</span><span class="p">,</span> <span class="s1">&#39;Bar&#39;</span><span class="p">,</span> <span class="s1">&#39;Torr&#39;</span><span class="p">,</span> <span class="s1">&#39;mmHg&#39;</span><span class="p">,</span> <span class="s1">&#39;atm&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the</span>
    <span class="c1"># string used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">Pa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Pascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mi">46480</span> <span class="o">*</span> <span class="n">v_avg</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mi">46480</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mi">46480</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">kPa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in kiloPascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">46.480</span> <span class="o">*</span> <span class="n">v_avg</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">46.480</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">46.480</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">Bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Bars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">.46480</span> <span class="o">*</span> <span class="n">v_avg</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">.46480</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">.46480</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">Torr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Torr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>

    <span class="k">def</span> <span class="nf">mmHg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in mmHg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Torr</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">atm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in atm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class contains the definitions for Vernier absolute gas pressure
sensor, GPS-BTA (pre 2011 manufacture. Label does not depict a caliper
with the registered trademark symbol).</p>
</div>


                            <div id="VernierGasP_OLD.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP_OLD.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">VernierGasP_OLD</span><span class="signature">(Vdd)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Absolute Gas Pressure Sensor (New)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier (manufactured after 2011)&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;Pa&#39;</span><span class="p">,</span> <span class="s1">&#39;kPa&#39;</span><span class="p">,</span> <span class="s1">&#39;Bar&#39;</span><span class="p">,</span> <span class="s1">&#39;Torr&#39;</span><span class="p">,</span> <span class="s1">&#39;mmHg&#39;</span><span class="p">,</span> <span class="s1">&#39;atm&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>This init should be called first in the init section of any class
extending this class (e.g. <code>super().__init__(Vdd)</code>). Then set
<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units
specific to the sensor to <code>self.units</code>. The parameter Vdd must be
supplied upon initialization because the output voltage of some
sensors depends on Vdd.</p>

<p>:param float Vdd: the voltage supplied to the sensor by the A-to-D
 board in case the sensor output depends on this.</p>
</div>


                            </div>
                            <div id="VernierGasP_OLD.Pa" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP_OLD.Pa">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Pa</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Pa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Pascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mi">46480</span> <span class="o">*</span> <span class="n">v_avg</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mi">46480</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mi">46480</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the raw voltage
:param float avg_std: estimated standard deviation of v_avg
:param float avg_vdd: the Vdd measured simultaneously with v_avg (not
used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in Pascals</p>
</div>


                            </div>
                            <div id="VernierGasP_OLD.kPa" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP_OLD.kPa">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">kPa</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">kPa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in kiloPascals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">46.480</span> <span class="o">*</span> <span class="n">v_avg</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">46.480</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">46.480</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the raw voltage
:param float avg_std: estimated standard deviation of v_avg
:param float avg_vdd: the Vdd measured simultaneously with v_avg (not
used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in kiloPascals</p>
</div>


                            </div>
                            <div id="VernierGasP_OLD.Bar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP_OLD.Bar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Bar</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Bars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="mf">.46480</span> <span class="o">*</span> <span class="n">v_avg</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="mf">.46480</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="mf">.46480</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the raw voltage
:param float avg_std: estimated standard deviation of v_avg
:param float avg_vdd: the Vdd measured simultaneously with v_avg (not
used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in Bars</p>
</div>


                            </div>
                            <div id="VernierGasP_OLD.Torr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP_OLD.Torr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Torr</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Torr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in Torr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">*</span> <span class="mf">760.0</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the voltage measurements
:param float avg_std: estimate of the standard deviation of the average
:param float avg_vdd: the Vdd measured simultaneously with v_avg (
not used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in Torr</p>
</div>


                            </div>
                            <div id="VernierGasP_OLD.mmHg" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP_OLD.mmHg">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">mmHg</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">mmHg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in mmHg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Torr</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the voltage measurements
:param float avg_std: estimate of the standard deviation of the average
:param float avg_vdd: the Vdd measured simultaneously with v_avg (
not used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in mmHg</p>
</div>


                            </div>
                            <div id="VernierGasP_OLD.atm" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierGasP_OLD.atm">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">atm</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">atm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the voltage measurements</span>
<span class="sd">        :param float avg_std: estimate of the standard deviation of the average</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (</span>
<span class="sd">        not used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: P_avg, P_std, P_avg_std all in atm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pa</span><span class="p">(</span><span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">)</span>
        <span class="n">P_avg</span> <span class="o">=</span> <span class="n">P_avg</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_std</span> <span class="o">=</span> <span class="n">P_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="n">P_avg_std</span> <span class="o">=</span> <span class="n">P_avg_std</span> <span class="o">/</span> <span class="mi">101325</span>
        <span class="k">return</span> <span class="n">P_avg</span><span class="p">,</span> <span class="n">P_std</span><span class="p">,</span> <span class="n">P_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the voltage measurements
:param float avg_std: estimate of the standard deviation of the average
:param float avg_vdd: the Vdd measured simultaneously with v_avg (
not used)
:return list:</p>

<p>Returns: P_avg, P_std, P_avg_std all in atm</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#RawAtoD">RawAtoD</a></dt>
                                <dd id="VernierGasP_OLD.getname" class="function"><a href="#RawAtoD.getname">getname</a></dd>
                <dd id="VernierGasP_OLD.getvendor" class="function"><a href="#RawAtoD.getvendor">getvendor</a></dd>
                <dd id="VernierGasP_OLD.getunits" class="function"><a href="#RawAtoD.getunits">getunits</a></dd>
                <dd id="VernierGasP_OLD.V" class="function"><a href="#RawAtoD.V">V</a></dd>
                <dd id="VernierGasP_OLD.mV" class="function"><a href="#RawAtoD.mV">mV</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="VernierpH">
                                <div class="attr class">
        <a class="headerlink" href="#VernierpH">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">VernierpH</span><wbr>(<span class="base"><a href="#RawAtoD">RawAtoD</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">VernierpH</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for Vernier standard pH</span>
<span class="sd">    sensor, PH-BTA.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Standard pH Sensor&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;pH&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the</span>
    <span class="c1"># string used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">pH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: pH_avg, pH_std, pH_avg_std all in pH units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pH_avg</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.838</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="mf">13.720</span>
        <span class="n">pH_std</span> <span class="o">=</span> <span class="mf">3.838</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">pH_avg_std</span> <span class="o">=</span> <span class="mf">3.838</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">pH_avg</span><span class="p">,</span> <span class="n">pH_std</span><span class="p">,</span> <span class="n">pH_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class contains the definitions for Vernier standard pH
sensor, PH-BTA.</p>
</div>


                            <div id="VernierpH.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierpH.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">VernierpH</span><span class="signature">(Vdd)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Standard pH Sensor&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;pH&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>This init should be called first in the init section of any class
extending this class (e.g. <code>super().__init__(Vdd)</code>). Then set
<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units
specific to the sensor to <code>self.units</code>. The parameter Vdd must be
supplied upon initialization because the output voltage of some
sensors depends on Vdd.</p>

<p>:param float Vdd: the voltage supplied to the sensor by the A-to-D
 board in case the sensor output depends on this.</p>
</div>


                            </div>
                            <div id="VernierpH.pH" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierpH.pH">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">pH</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">pH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: pH_avg, pH_std, pH_avg_std all in pH units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pH_avg</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.838</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="mf">13.720</span>
        <span class="n">pH_std</span> <span class="o">=</span> <span class="mf">3.838</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">pH_avg_std</span> <span class="o">=</span> <span class="mf">3.838</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">pH_avg</span><span class="p">,</span> <span class="n">pH_std</span><span class="p">,</span> <span class="n">pH_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the raw voltage
:param float avg_std: estimated standard deviation of v_avg
:param float avg_vdd: the Vdd measured simultaneously with v_avg (not
used)
:return list:</p>

<p>Returns: pH_avg, pH_std, pH_avg_std all in pH units</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#RawAtoD">RawAtoD</a></dt>
                                <dd id="VernierpH.getname" class="function"><a href="#RawAtoD.getname">getname</a></dd>
                <dd id="VernierpH.getvendor" class="function"><a href="#RawAtoD.getvendor">getvendor</a></dd>
                <dd id="VernierpH.getunits" class="function"><a href="#RawAtoD.getunits">getunits</a></dd>
                <dd id="VernierpH.V" class="function"><a href="#RawAtoD.V">V</a></dd>
                <dd id="VernierpH.mV" class="function"><a href="#RawAtoD.mV">mV</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="VernierFlatpH">
                                <div class="attr class">
        <a class="headerlink" href="#VernierFlatpH">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">VernierFlatpH</span><wbr>(<span class="base"><a href="#RawAtoD">RawAtoD</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">VernierFlatpH</span><span class="p">(</span><span class="n">RawAtoD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the definitions for Vernier flat tris-compatible pH</span>
<span class="sd">    sensor, FPH-BTA.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Flat pH Sensor&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;pH&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>

    <span class="c1">###</span>
    <span class="c1"># Sensor specific units. Notice the function names must match the</span>
    <span class="c1"># string used for the units.</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">pH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: pH_avg, pH_std, pH_avg_std all in pH units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pH_avg</span> <span class="o">=</span> <span class="o">-</span><span class="mf">7.78</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="mf">16.34</span>
        <span class="n">pH_std</span> <span class="o">=</span> <span class="mf">7.78</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">pH_avg_std</span> <span class="o">=</span> <span class="mf">7.78</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">pH_avg</span><span class="p">,</span> <span class="n">pH_std</span><span class="p">,</span> <span class="n">pH_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class contains the definitions for Vernier flat tris-compatible pH
sensor, FPH-BTA.</p>
</div>


                            <div id="VernierFlatpH.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierFlatpH.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">VernierFlatpH</span><span class="signature">(Vdd)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vdd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Vdd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Vernier Flat pH Sensor&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="s1">&#39;Vernier&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;pH&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vdd</span> <span class="o">=</span> <span class="n">Vdd</span>
        <span class="k">pass</span>
</pre></div>

        </details>

            <div class="docstring"><p>This init should be called first in the init section of any class
extending this class (e.g. <code>super().__init__(Vdd)</code>). Then set
<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units
specific to the sensor to <code>self.units</code>. The parameter Vdd must be
supplied upon initialization because the output voltage of some
sensors depends on Vdd.</p>

<p>:param float Vdd: the voltage supplied to the sensor by the A-to-D
 board in case the sensor output depends on this.</p>
</div>


                            </div>
                            <div id="VernierFlatpH.pH" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#VernierFlatpH.pH">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">pH</span><span class="signature">(self, v_avg, v_std, avg_std, avg_vdd)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">pH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_avg</span><span class="p">,</span> <span class="n">v_std</span><span class="p">,</span> <span class="n">avg_std</span><span class="p">,</span> <span class="n">avg_vdd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param float v_avg: average raw voltage</span>
<span class="sd">        :param float v_std: standard deviation of the raw voltage</span>
<span class="sd">        :param float avg_std: estimated standard deviation of v_avg</span>
<span class="sd">        :param float avg_vdd: the Vdd measured simultaneously with v_avg (not</span>
<span class="sd">        used)</span>
<span class="sd">        :return list:</span>

<span class="sd">        Returns: pH_avg, pH_std, pH_avg_std all in pH units</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pH_avg</span> <span class="o">=</span> <span class="o">-</span><span class="mf">7.78</span> <span class="o">*</span> <span class="n">v_avg</span> <span class="o">+</span> <span class="mf">16.34</span>
        <span class="n">pH_std</span> <span class="o">=</span> <span class="mf">7.78</span> <span class="o">*</span> <span class="n">v_std</span>
        <span class="n">pH_avg_std</span> <span class="o">=</span> <span class="mf">7.78</span> <span class="o">*</span> <span class="n">avg_std</span>
        <span class="k">return</span> <span class="n">pH_avg</span><span class="p">,</span> <span class="n">pH_std</span><span class="p">,</span> <span class="n">pH_avg_std</span>
</pre></div>

        </details>

            <div class="docstring"><p>:param float v_avg: average raw voltage
:param float v_std: standard deviation of the raw voltage
:param float avg_std: estimated standard deviation of v_avg
:param float avg_vdd: the Vdd measured simultaneously with v_avg (not
used)
:return list:</p>

<p>Returns: pH_avg, pH_std, pH_avg_std all in pH units</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#RawAtoD">RawAtoD</a></dt>
                                <dd id="VernierFlatpH.getname" class="function"><a href="#RawAtoD.getname">getname</a></dd>
                <dd id="VernierFlatpH.getvendor" class="function"><a href="#RawAtoD.getvendor">getvendor</a></dd>
                <dd id="VernierFlatpH.getunits" class="function"><a href="#RawAtoD.getunits">getunits</a></dd>
                <dd id="VernierFlatpH.V" class="function"><a href="#RawAtoD.V">V</a></dd>
                <dd id="VernierFlatpH.mV" class="function"><a href="#RawAtoD.mV">mV</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">${doc.signature}:</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value">${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>