window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "jupyterpidaq", "modulename": "jupyterpidaq", "type": "module", "doc": "<h1 id=\"user-guide\">User Guide</h1>\n\n<p><a href=\"#introduction\">Introduction</a> | \n<a href=\"#usage\">Usage</a></p>\n\n<h2 id=\"introduction\">Introduction</h2>\n\n<p>This software allows realtime collection and plotting of \ndigitized data in  a Jupyter notebook using either of the following two\ninterface boards on a Raspberry Pi:</p>\n\n<ul>\n<li>Adafruit compliant ADS1115 boards \n(<a href=\"https://www.amazon.com/KNACRO-4-Channel-Raspberry-ADS1115-Channel/dp/B07149WH7P\">example</a>,\nalso available from other vendors);</li>\n<li>The <a href=\"https://pi-plates.com/daqc2r1/\">&pi;-Plates DAQC2 plate</a>. </li>\n<li>A demo mode will run on any computer with a Jupyter notebook install and\nPython 3.6+. You can try the demo mode without installing on your own \ncomputer by launching an instance on the MyBinder servers:\n<a href=\"https://mybinder.org/v2/gh/JupyterPhysSciLab/JupyterPiDAQ.git/HEAD?urlpath=/tree/usage_examples/\"><img src=\"https://mybinder.org/badge_logo.svg\" alt=\"Binder\" /></a>.\nExample notebooks can be found in the \"usage_examples\" folder.</li>\n</ul>\n\n<h2 id=\"usage\">Usage</h2>\n\n<p><a href=\"#starting-jupyterpidaq\">Launch the software</a> | \n<a href=\"#initialize-the-data-acquisition-tools\">Initialize data acquisiton tools</a> | \n<a href=\"#collecting-data\">Collect data</a> |\n<a href=\"#in-a-table\">Displaying a Data Table</a> | \n<a href=\"#plotting-data\">Plotting data</a> | \n<a href=\"#analyzing-data\">Analyzing data</a> </p>\n\n<h3 id=\"starting-jupyterpidaq\">Starting JupyterPiDAQ</h3>\n\n<p>A working Jupyter notebook installation with JupyterPiDAQ installed is\nrequired. If you need to install the software see the <a href=\"https://jupyterphysscilab.github.io/JupyterPiDAQ/jupyterpidaq.html#installation\">Installation \nInstructions</a>. There are two common ways this may be set \nup, that lead to slightly different steps for starting the software:</p>\n\n<ol>\n<li><em>A special kernel</em> may be set up that can be used in any Jupyter notebook \ninstall for the current user (see the very end of the\n<a href=\"https://jupyterphysscilab.github.io/JupyterPiDAQ/jupyterpidaq.html#installation\">Installation Instructions</a>). \n<ul>\n<li>In this case launch\nJupyter, in whichever directory you want to work, using the \ncommand: <code>jupyter notebook</code>.</li>\n<li>Open a new notebook and choose the kernel \nfor <code>JupyterPiDAQ</code>. The kernel name will depend upon what was chosen \nduring installation.</li>\n</ul></li>\n<li><strong>Only for use within the directory structure of the virtual environment</strong> \nthat was set up for the software. \n<ul>\n<li>In this case you must navigate to the \ndirectory of the virtual environment using the <code>cd</code> command before \nstarting the software.</li>\n<li>Then enter the virtual environment with the command <code>pipenv shell</code>. \nThis assumes you set up <code>pipenv</code> as described in the \n<a href=\"https://jupyterphysscilab.github.io/JupyterPiDAQ/jupyterpidaq.html#installation\">Installation instructions</a>.</li>\n<li>Launch Jupyter using the command: <code>jupyter notebook</code>.</li>\n<li>Open a new python notebook.</li>\n</ul></li>\n</ol>\n\n<h3 id=\"initialize-the-data-acquisition-tools\">Initialize the Data Acquisition Tools</h3>\n\n<p>Initialize the data acquisition tools by putting the statement <code>from \njupyterpidaq.DAQinstance import *</code> into the first cell and clicking on the \n'Run' button. The package loads supporting packages (numpy, pandas, plotly,\netc...) and searches for compatible hardware. On a Raspberry Pi this takes a\nnumber of seconds. If no compatible A-to-D boards are found, demo mode is used.\nIn demo mode the A-to-D board is simulated by a random number generator.</p>\n\n<p>When setup is done a new menu appears at the end of the menubar (figure 1).</p>\n\n<p><img src=\"DAQmenu.png\" alt=\"DAQ Menu\" /></p>\n\n<p><strong>Figure 1</strong>: The menu created once the data acquisition software is \ninitialized.</p>\n\n<p>The menu options insert jupyter widget based GUIs for starting a run,\ndisplaying the data as tables or plots, composing an expression to calculate\na new column in a DataFrame, or fitting data.</p>\n\n<h3 id=\"collecting-data\">Collecting data</h3>\n\n<p>From the \"DAQ Commands\" menu select \"Insert New Run After Selection...\" or \n\"Append New Run to End...\". The first will insert and start the code to set up \ndata collection for a run in the cell below the currently selected cell. \nThe second will append this to the end of the notebook. This will generate \na GUI that looks like the figure 2, below. Fill in the information to define \nwhat you wish to do (see below figure 2 for more details).</p>\n\n<p><img src=\"newrun.png\" alt=\"New Run Figure\" /></p>\n\n<p><strong>Figure 2</strong>: Image of the GUI for setting up a data collection run.</p>\n\n<ol>\n<li>Give the run a title/name using the first textbox.</li>\n<li>You can collect up to four (4) data traces at once. Two different data \ntraces can display the same analog-to-digital channel, but in different \nunits (e.g. you could record both the raw voltage and temperature from a \nthermistor). Each trace is activated by selecting its checkbox.</li>\n<li>Once a trace is activated you can give it a title and must select: the \ndata acquisition board, channel, sensor, units and gain from the \navailable drop-down menus.</li>\n<li>Once all your traces are set up decide whether they should be displayed in \nmultiple stacked graphs or all on the same graph. Uncheck the box to \ndisplay all on one graph.</li>\n<li>Select the data collection rate (3 Hz is currently the maximum rate).</li>\n<li>When everything is set the way you wish, click on the \"Set Parameters\" \nbutton. The collection parameters will be displayed and a button to \nstart the data collection will appear.</li>\n<li>The \"start\" button will convert to a \"stop\" button once data collection \nis started. The data graph(s) will update at roughly 1 Hz, so you can \nmonitor the progress of the data collection.</li>\n<li>Click the \"stop\" button to end data collection. It can take \na while to stop if the data collection has got ahead of the graphic \ndisplay of the data.</li>\n<li>Once collection is stopped you will see a plot or plots of the completed \ndata collection and the name of the .html file the raw data has been \nbacked up to.</li>\n<li>Should you accidentally clear the output of the collection results cell,\nrerunning it will regenerate the display.</li>\n</ol>\n\n<h3 id=\"displaying-data\">Displaying data</h3>\n\n<h4 id=\"in-a-table\">In a table</h4>\n\n<p>Selecting the \"Show data in table...\" option in the \"DAQ Command\" menu will \ninsert a cell immediately below the currently selected cell displaying a \nwidget in which you can select which data set to display.</p>\n\n<h4 id=\"plotting-data\">Plotting data</h4>\n\n<p>Selecting the \"Insert new plot after selection...\" option in the menu will\ninsert two cells immediately below the currently selected cell. The first cell\nwill be used to generate a GUI to lead you through creation of the code to\ngenerate the plot. The second cell is where the plot creation code is \ngenerated. The first tab of this GUI looks like figure 3.</p>\n\n<p><img src=\"plot_GUI.png\" alt=\"Plot GUI\" /></p>\n\n<p><strong>Figure 3</strong>: Image of the first tab in the four tab (4 step) Pandas Plot \nComposer. More information in the <a href=\"https://jupyterphysscilab.github.io/jupyter_Pandas_GUI/\">Pandas_GUI\ndocumentation</a>.</p>\n\n<p>It is best to do the tabs in order. The notices in red will try to \nwarn you of errors or oversights. The \"Instructions\" accordian can be \nexpanded to get more specific information about how to use each tab.</p>\n\n<p>You can get more sophisticated control of \nyour plot by editing the code produced by this GUI. See the <a href=\"https://plotly.com/python/figurewidget/\">Plotly \nFigureWidget Instructions</a> and the \nexample Jupyter notebooks referenced there for more information.</p>\n\n<p>The GUI destroys itself once you complete step 4.</p>\n\n<h3 id=\"analyzing-data\">Analyzing data</h3>\n\n<h4 id=\"calculating-a-new-column\">Calculating a new column</h4>\n\n<p>Selecting \"Calculate new column...\" from the menu will add two cells\nimmediately below the selected cell. The first cell will create the GUI to\nlead you through creation of the code to calculate the new column. The second\ncell is where the code is built. The first tab of the GUI looks like figure 4.</p>\n\n<p><img src=\"new_col_GUI.png\" alt=\"New Column GUI\" /></p>\n\n<p><strong>Figure 4</strong>: Image of the first tab in the four tab (4 step) Pandas New \nCalculated Column Composer. More information in the <a href=\"https://jupyterphysscilab.github.io/jupyter_Pandas_GUI/\">Pandas_GUI\ndocumentation</a>.</p>\n\n<p>Do the tabs in order. You can perform more complex manipulations than built \ninto the GUI by editing the code generated by this GUI.</p>\n\n<p>The GUI destroys itself once you complete step 4.</p>\n\n<h4 id=\"fitting-data\">Fitting data</h4>\n\n<p>A GUI for defining simple fits (linear, polynomial, exponential decay, sine \nand Gaussian) can be launched by selecting \"Insert new Fit after selection..\n.\" from the menu. This will create the GUI to lead you through selecting \nand fitting the data. The code is created in the cell immediately below the \nGUI.</p>\n\n<p><img src=\"fit_gaussian_tab1.png\" alt=\"Fit Pandas GUI\" /></p>\n\n<p><strong>Figure 5</strong>: Image of the first tab in the Pandas Fit Composer.\nMore information in the <a href=\"https://jupyterphysscilab.github.io/jupyter_Pandas_GUI/\">Pandas_GUI\ndocumentation</a>.</p>\n\n<h1 id=\"installation\">Installation</h1>\n\n<p>Initial setup: <a href=\"#raspberry-pi-initial-setup\">On Raspberry Pi</a> | \n<a href=\"#non-pi-based-system-initial-setup\">On non-Pi Systems</a></p>\n\n<p><a href=\"#final-set-up\">Final Set up</a></p>\n\n<h2 id=\"raspberry-pi-initial-setup\">Raspberry Pi Initial Setup</h2>\n\n<p>Unless you only want to run in Demo mode make sure you have one of the \ncompatible interface boards installed. The current options are:</p>\n\n<ul>\n<li>Adafruit compliant ADS1115 boards \n(<a href=\"https://www.amazon.com/KNACRO-4-Channel-Raspberry-ADS1115-Channel/dp/B07149WH7P\">example</a>,\nalso available from other vendors);</li>\n<li>The <a href=\"https://pi-plates.com/daqc2r1/\">&pi;-Plates DAQC2 plate</a>.</li>\n<li>If you wish to use different interfaces  see the <a href=\"https://jupyterphysscilab.github.io/JupyterPiDAQ/jupyterpidaq.html#development-notes\">Development\nNotes</a>\nand the <code>Boards</code> subpackage of <code>jupyterpidaq</code> for examples and \ninformation on how to define the code interface for a board.</li>\n</ul>\n\n<p>OS specific: <a href=\"#*ubuntu-on-pi*\">Ubuntu on Pi</a> | \n<a href=\"#*raspberrian-on-pi*\">Raspberrian on Pi</a></p>\n\n<h3 id=\"ubuntu-on-pi\"><em>Ubuntu on Pi</em></h3>\n\n<p>By default in Ubuntu 20.04 for Pis the gpio and spi groups do not exist.\nThe i2c group does (not always).</p>\n\n<ol>\n<li>Make sure that the following packages are installed <code>rpi.gpio-common \npython3-pigpio python3-gpiozero python3-rpi.gpio</code>.</li>\n<li>You can avoid having to create a gpio group, by assigning users who need\ngpio access to the dialout group. Check that /dev/gpiomem is part of that \ngroup and that the dialout group has rw access. If not you will need to set\nit.</li>\n<li>Users also need to be members of the i2c group. If it does not exist create \nit and then make that the group for /dev/i2c-1 with group rw permissions. \nTHIS MAY NOT BE NECESSARY. </li>\n<li>The spi group needs to be created (addgroup?).</li>\n<li>Additionally the spi group needs to be given rw access to the spi devices\nat each boot. To do this create a one line rule in a file named \n<code>/etc/udev/rules.d/50-spidev.rules</code> containing <code>SUBSYSTEM==\"spidev\", \nGROUP=\"spi\", MODE=\"0660\"</code>. The file should have rw permission for root \nand read permission for everyone else.</li>\n<li>Make sure you have <a href=\"https://pip.pypa.io/en/stable/\">pip</a> installed for \npython 3: <code>python3 -m pip --version</code> or <code>pip3 --version</code>. If you do not, \ninstall using <code>apt \ninstall python3-pip</code>.</li>\n</ol>\n\n<h3 id=\"raspberrian-on-pi\"><em>Raspberrian on Pi</em></h3>\n\n<p>(TBD)</p>\n\n<h2 id=\"non-pi-based-system-initial-setup\">Non-Pi based System Initial Setup</h2>\n\n<p>Make sure that Python &gt;=3.6 is installed: <code>python3 -v</code>. If not follow \ninstructions at <a href=\"https://python.org\">python.org</a>. This software should run \non any computer capable of supporting the necessary version of Python. \nHowevever, it will only run in demo mode if the computer does not support \none of the compatible A-to-D boards.</p>\n\n<h3 id=\"generic-linux\"><em>Generic Linux</em></h3>\n\n<ul>\n<li>If your system hardware \nhas GPIO pins and a GPIO interface board, you should try following the \ninstructions for a <a href=\"#raspberry-pi-initial-setup\">Pi based system</a> above. If \nyou figure out how to make this work on other SBCs or systems with GPIO, \nplease submit a pull request updating these instructions.</li>\n<li>If your system hardware does not support GPIO and one of the compatible \ninterface boards, the software will run in demo mode.</li>\n</ul>\n\n<p>NOTE: If a binary distribution (whl or wheel) is not available for your\nplatform, some of the required packages may need to be compiled. If you get\ncompilation errors when installing try getting the python header and \ndevelopment files for your platform. To get them on most *nix platforms use the\ncommand <code>$ sudo apt install python3-dev</code>.</p>\n\n<h3 id=\"macos\"><em>MacOS</em></h3>\n\n<h3 id=\"windows-please-no\"><em>Windows (Please, no.....)</em></h3>\n\n<h2 id=\"final-set-up\">Final Set Up</h2>\n\n<p>Make sure the user you will be running the software under is a member of the \ngroups <code>dialout</code>, <code>spi</code> and if it exists<code>i2c</code>. It is recommended that you \ninstall JupyterPiDAQ in its own \n<a href=\"https://docs.python.org/3/tutorial/venv.html?highlight=virtual%20environments\">virtual environment</a>.\nThe instructions below do just that using the original author's favorite \nvirtual environment tool <a href=\"https://pipenv.pypa.io/en/latest/\">pipenv</a>.</p>\n\n<p>Log into your chosen user account:</p>\n\n<ol>\n<li>Install <a href=\"https://pipenv.pypa.io/en/latest/\">pipenv</a>: <code>pip3 install \n--user pipenv</code>. You may\nneed to add <code>~/.local/bin</code> to your <code>PATH</code> to make <code>pipenv</code>\navailable in your command shell. More discussion: \n<a href=\"https://docs.python-guide.org/dev/virtualenvs/\">The Hitchhiker's Guide to\nPython</a>.</li>\n<li>Create a directory for the virtual environment you will be installing\ninto (example: <code>$ mkdir JupyterPiDAQ</code>).</li>\n<li>Navigate into the directory <code>$ cd JupyterPiDAQ</code>.</li>\n<li>Create the virtual environment and enter it <code>$ pipenv shell</code>. To get out of\nthe environment you can issue the <code>$ exit</code> command on the command line.</li>\n<li>While still in the shell install the latest JupyterPiDAQ and all its\nrequirements\n<code>$ pip install -U JupyterPiDAQ</code>. This can take a long time, especially on a\nRaspberry Pi. On a Pi 3B+ (minimum requirement) it will probably not run\nwithout at least 1 GB of swap. See: <a href=\"a href=&quot;https://cms.gutow.uwosh.edu/Gutow/useful-chemistry-links/software-tools-and-coding/computer-and-coding-how-tos/installing-jupyter-on-raspberrian&quot;&gt;https://cms.gutow.uwosh.edu/Gutow/useful-chemistry-links/software-tools-and-coding/computer-and-coding-how-tos/installing-jupyter-on-raspberrian&lt;/a\">Build Jupyter on a Pi</a>\nfor a discussion of adding swap space on a Pi.</li>\n<li>Still within the environment shell test\nthis by starting jupyter <code>$ jupyter notebook</code>. Jupyter should launch in your browser.\n<ol>\n<li>Open a new notebook using the default (Python 3) kernel.</li>\n<li>In the first cell import all from DAQinstance.py: \n<code>from jupyterpidaq.DAQinstance import *</code>.\nWhen run this cell should load the DAQmenu at the end of the Jupyter\nnotebook menu/icon bar. If you do not have an appropriate A-to-D\nboard installed you will get a message and the software\nwill default to demo mode, substituting a random number\ngenerator for the A-to-D. Because of the demo mode it is\npossible to run this on any computer, not just a Pi.</li>\n</ol></li>\n<li>If you wish, you can make this environment available to an alternate Jupyter\ninstall as a special kernel when you are the user.\n<ol>\n<li>Make sure you are running in your virtual environment <code>$ pipenv shell</code> \nin the directory for  virtual environment will do that.</li>\n<li>Issue the command to add this as a kernel to your personal space: \n<code>$ python -m ipykernel install --user --name=&lt;name-you-want-for-kernel&gt;</code>.</li>\n<li>More information is available in the Jupyter/Ipython documentation. \nA simple tutorial from Nikolai Jankiev (_Parametric Thoughts_) can be\nfound <a href=\"https://janakiev.com/til/jupyter-virtual-envs/\">here</a>. </li>\n</ol></li>\n</ol>\n\n<h1 id=\"development-notes\">Development Notes</h1>\n\n<h2 id=\"code-repositoryhttpsgithubcomjupyterphysscilabjupyterpidaq\"><a href=\"https://github.com/JupyterPhysSciLab/JupyterPiDAQ\">Code Repository</a></h2>\n\n<h2 id=\"setting-up-development-environment\">Setting up Development Environment</h2>\n\n<p>Basic requirements: Python 3.6+, associated\npip and a Jupyter notebook.\nSee: <a href=\"https://python.org\">python.org</a> and\n<a href=\"https://jupyter.org\">Jupyter.org</a>.</p>\n\n<ol>\n<li>If not installed, install pipenv:<code>$ pip3 install --user pipenv</code>. You may\nneed to add <code>~/.local/bin</code> to your <code>PATH</code> to make <code>pipenv</code>\navailable in your command shell. More discussion: \n<a href=\"https://docs.python-guide.org/dev/virtualenvs/\">The Hitchhiker's Guide to Python</a>.</li>\n<li>Navigate to the directory where this package will be\nor has been downloaded to. Use <code>pipenv</code>to install an \n<a href=\"https://pip.pypa.io/en/stable/reference/pip_install/#editable-installs\">\"editable\" package</a> \ninside the directory as described below:\n<ol>\n<li>Start a shell in the environment <code>$ pipenv shell</code>.</li>\n<li>Install using pip.\n<ol>\n<li>If you downloaded the git repository named \"JupyterPiDAQ\"\nand have used that directory to build your virtual\nenvironment: <code>$ pip install -e ../JupyterPiDAQ/</code>.</li>\n<li>If you are downloading from PyPi\n<code>$ pip install -e JupyterPiDAQ</code></li>\n<li>Either should install all the additional packages this\npackage depends upon. On a Raspberry Pi this will take\na long time. It probably will not run without at least 1 GB of swap. See: \n<a href=\"https://www.uwosh.edu/facstaff/gutow/computer-and-programming-how-tos/installing-jupyter-on-raspberrian\">Build Jupyter on a Pi\n</a>.</li>\n</ol></li>\n<li>Still within the environment shell test\nthis by starting jupyter <code>$ jupyter notebook</code>. Jupyter should launch in\nyour browser.\n<ol>\n<li>Open a new notebook using the default (Python 3) kernel.</li>\n<li>In the first cell import all from DAQinstance.py: \n<code>from jupyterpidaq.DAQinstance import *</code>.\nWhen run this cell should load the DAQmenu at the end of the\nJupyter notebook menu/icon bar. If you do not have an appropriate A-to-D\nboard installed you will get a message and the software\nwill default to demo mode, substituting a random number\ngenerator for the A-to-D. Because of the demo mode it is\npossible to run this on any computer, not just a Pi.</li>\n</ol></li>\n</ol></li>\n<li>If you wish, you can make this environment available to an alternate Jupyter\ninstall as a special kernel when you are the user.\n<ol>\n<li>Make sure you are running in your virtual environment <code>$ pipenv shell</code> \nin the directory for  virtual environment will do that.</li>\n<li>Issue the command to add this as a kernel to your personal space: \n<code>$ python -m ipykernel install --user --name=&lt;name-you-want-for-kernel&gt;</code>.</li>\n<li>More information is available in the Jupyter/Ipython documentation. \nA simple tutorial from Nikolai Jankiev (_Parametric Thoughts_) can be\nfound <a href=\"https://janakiev.com/til/jupyter-virtual-envs/\">here</a>. </li>\n</ol></li>\n</ol>\n\n<h2 id=\"adding-new-sensor-code\">Adding New Sensor Code</h2>\n\n<ol>\n<li>Copy an existing sensor class paste it into the end of\nsensors.py and rename it.</li>\n<li>Update/delete functions for each valid unit within the new\nclass as necessary.</li>\n<li>Update the sensor name, vendor and available units in the\n<code>__init__</code> function.</li>\n<li>Add the new sensor classname to the list of available sensors\nin <code>listSensors</code> at about line 120 of sensors.py.</li>\n<li>Add the new sensor classname to <code>getsensors</code> of ADCsim.py,\nADCsim_line.py and any board (e.g. DAQC2.py) with which the sensor\ncan be used. <em>Do not guess if a sensor works with a particular\nboard. Test it!</em></li>\n</ol>\n\n<h2 id=\"running-tests\">Running Tests</h2>\n\n<ol>\n<li>Install updated pytest in the virtual environment:\n<code>\npipenv shell\npip install -U pytest\n</code></li>\n<li>Run tests ignoring the manual tests in the <code>dev_testing</code> directory:\n<code>python -m pytest --ignore='dev_testing'</code>.</li>\n</ol>\n\n<h2 id=\"building-documentation\">Building Documentation</h2>\n\n<ol>\n<li>Install or update pdoc into the virtual environment <code>pip install -U pdoc</code>.</li>\n<li>Make edits to the <code>.md</code> files within the docs folder that are to be \nincluded in the first page (see <code>__init__.py</code> of the jupyterpidaq package).</li>\n<li>At the root level run <code>pdoc \n--logo https://jupyterphysscilab.github.io/JupyterPiDAQ/JupyterPiDAQ-logo.svg --logo-link \nhttps://jupyterphysscilab.github.io/JupyterPiDAQ/ --footer-text \n\"JupyterPiDAQ vX.X.X\" -html -o docs jupyterpidaq</code> Unless you are on a \nRaspbery Pi this will throw an error about <code>import</code>. Just ignore.</li>\n</ol>\n\n<h2 id=\"building-pypi-package\">Building PyPi package</h2>\n\n<ol>\n<li>Make sure to update the version number in setup.py first.</li>\n<li>Install updated  setuptools and twine in the virtual environment:\n<code>\npipenv shell\npip install -U setuptools wheel twine\n</code></li>\n<li>Build the distribution <code>python -m setup sdist bdist_wheel</code>.</li>\n<li>Test it on <code>test.pypi.org</code>.\n<ol>\n<li>Upload it (you will need an account on test.pypi.org):\n<code>python -m twine upload --repository testpypi dist/*</code>.</li>\n<li>Create a new virtual environment and test install into it:\n<code>\nexit # to get out of the current environment\ncd &lt;somewhere&gt;\nmkdir &lt;new virtual environment&gt;\ncd &lt;new directory&gt;\npipenv shell #creates the new environment and enters it.\npip install -i https://test.pypi.org/..... # copy actual link from the\n                                           # repository on test.pypi.\n</code>\nThere are often install issues because sometimes only older versions of\nsome of the required packages are available on test.pypi.org. If this\nis the only problem change the version to end in <code>rc0</code> for release\ncandidate and try it on the regular pypi.org as described below for\nreleasing on PyPi.</li>\n<li>After install test by running a jupyter notebook in the virtual \nenvironment.</li>\n</ol></li>\n</ol>\n\n<h2 id=\"releasing-on-pypi\">Releasing on PyPi</h2>\n\n<p>Proceed only if testing of the build is successful.</p>\n\n<ol>\n<li>Double check the version number in setup.py.</li>\n<li>Rebuild the release: <code>python -m setup sdist bdist_wheel</code>.</li>\n<li>Upload it: <code>python -m twine upload dist/*</code></li>\n<li>Make sure it works by installing it in a clean virtual environment. This\nis the same as on test.pypi.org except without <code>-i https://test.pypy...</code>. If\nit does not work, pull the release.</li>\n</ol>\n\n<h1 id=\"change-log\">Change Log</h1>\n\n<ul>\n<li>0.7.8\n<ul>\n<li>Updated text for insertion into cells to make better use of escaping \nupdates in JPSLUtils &gt;=0.7.0.</li>\n<li>Removed some unnecessary print statements.</li>\n</ul></li>\n<li>0.7.7\n<ul>\n<li>Updated requirements for upstream security fixes.</li>\n<li>Conversion to pandas dataframe now works when trace 0 is not collected.</li>\n<li>DAQ menu no longer created in trusted notebooks if the data acquisition \ntools have not been initialized since the notebook was opened.</li>\n<li>Reworked the data collection so that opening an old notebook without \nrunning anything will not have any leftover inoperable or undefined \nwidgets.</li>\n<li>Reordered the live trace display to match the order of the names at right.</li>\n<li>Runs now saved to a human readable html file that includes the run \nconditions.</li>\n<li>As long as this html file is in the same directory as the notebook, the \nrun display can be recreated by running its cell after accidentally \nclearing the cell output.</li>\n<li>The cell displaying the results of a run is now protected against \ndeletion and editing.</li>\n</ul></li>\n<li>0.7.6\n<ul>\n<li>Converted to fancy menus (could make hierarchical).</li>\n</ul></li>\n<li>0.7.5\n<ul>\n<li>Added fitting to DAQ command menu.</li>\n<li>Documentation Enhancements: github.io website; first pass as API docs; \nreorganized documentation; MyBinder link now forces launch in classic \nnotebook; added plans for adapter board to connect Vernier Sensors.</li>\n</ul></li>\n<li>0.7.4.1\n<ul>\n<li>Improved layout of data collection.</li>\n<li>Better widget cleanup.</li>\n<li>Readme fixes.</li>\n</ul></li>\n<li>0.7.3 Pip install reliability fixes.</li>\n<li>0.7.2 Suppress Javascript error when not in JLab.</li>\n<li>0.7.1\n<ul>\n<li>Include Heat Capacity Lab example.</li>\n<li>Make menu show up in JLab (still not functional).</li>\n<li>Remove matplotlib baggage.</li>\n</ul></li>\n<li>0.7.0\n<ul>\n<li>Switched to plotly widget for plotting.</li>\n<li>Added Vernier pressure sensor calibrations (old and new).</li>\n<li>Jupyter widgets based new calculated column GUI.</li>\n<li>Jupyter widgets based new plot GUI.</li>\n<li>Default to providing only one time for channels collected nearly \nsimultaneously.</li>\n<li>As reported values are averages, switched to reporting the estimated \nstandard deviation of the average rather than the deviation of all the \nreadings used to create the average.</li>\n</ul></li>\n<li>0.6.0 \n<ul>\n<li>Initial release.</li>\n<li>Live data collection.</li>\n<li>Recognized sensors: ADS1115 boards (voltage, built-in thermistor, \nVernier SS temperature probe), DAQC2 boards (voltage,Vernier SS \ntemperature probe, Vernier standard pH probe, Vernier flat pH probe).</li>\n</ul></li>\n</ul>\n\n<h1 id=\"three-channel-adapter-board-for-vernier-sensors\">Three Channel Adapter Board for Vernier Sensors</h1>\n\n<h2 id=\"board-plans\">Board plans</h2>\n\n<p><img src=\"VernierAdapter.svg\" alt=\"board plans\" /></p>\n\n<h2 id=\"etching-the-board\">Etching the board</h2>\n\n<p>Clean Cu cladding to be etched by wet sanding with 1500 grit or finer.\nDraw traces with a black sharpie  \u201cindustrial super permanent ink\u201d version\nworks best. Allow to dry completely (no odor). Can be speeded up using a heat\ngun.</p>\n\n<h3 id=\"etchant-recipe\">Etchant recipe:</h3>\n\n<p>3 M HCl</p>\n\n<p>CuCl<sub>2</sub> to make medium emerald green solution (can also be made by \ndissolving Cu after adding hydrogen peroxide)</p>\n\n<p>Using test piece add 30% H<sub>2</sub>O<sub>2</sub> dropwise to get gentle \nbubbling and \ncomplete\nremoval in 3 \u2013 5 min (longer gives poorly defined edges).</p>\n"}, {"fullname": "jupyterpidaq.Boards", "modulename": "jupyterpidaq.Boards", "type": "module", "doc": "<p>This module wraps all the submodules related to communication and control of\ndata acquisition boards.</p>\n"}, {"fullname": "jupyterpidaq.Boards.PiGPIO", "modulename": "jupyterpidaq.Boards.PiGPIO", "type": "module", "doc": "<p>This module contains the modules for all PiGPIO based boards.</p>\n"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.ADS1115", "modulename": "jupyterpidaq.Boards.PiGPIO.ADS1115", "type": "module", "doc": "<p></p>\n"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.ADS1115.find_boards", "modulename": "jupyterpidaq.Boards.PiGPIO.ADS1115", "qualname": "find_boards", "type": "function", "doc": "<p>A routine like this must be implemented by all board packages.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of ADS1115 board objects (maximum of 4 boards)</p>\n</blockquote>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.ADS1115.Board_ADS1115", "modulename": "jupyterpidaq.Boards.PiGPIO.ADS1115", "qualname": "Board_ADS1115", "type": "class", "doc": "<p>Class defining the properties of Adafruit compatible ADS1115\nanalog-to-digital boards for Raspberry-Pi style GPIO. Key characteristics:</p>\n\n<ul>\n<li>4 channels (0 - 3) with 16 bit resolution and a range of +/- 3.3 V</li>\n<li>Programmable gain on each channel of 2/3, 1, 2, 4, 8, 16 making these\ngood for small signals.</li>\n<li>a differential mode is available but not implemented in this class.</li>\n</ul>\n", "bases": "jupyterpidaq.Boards.boards.Board"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.ADS1115.Board_ADS1115.__init__", "modulename": "jupyterpidaq.Boards.PiGPIO.ADS1115", "qualname": "Board_ADS1115.__init__", "type": "function", "doc": "<p>Should be overridden by each board and define at minimum:\nself.name = 'board name/adc name/type' Short an useful to end user\nself.vendor = 'Vendor/Manufacturer name`\nself.channels = tuple of available channel IDs\nself.gains = list of gains\nself.Vdd = voltage provided by board to sensors</p>\n", "signature": "(self, adc)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.ADS1115.Board_ADS1115.getsensors", "modulename": "jupyterpidaq.Boards.PiGPIO.ADS1115", "qualname": "Board_ADS1115.getsensors", "type": "function", "doc": "<p>Return a list of valid sensor object names for this board.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of classnames</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.ADS1115.Board_ADS1115.V_oversampchan", "modulename": "jupyterpidaq.Boards.PiGPIO.ADS1115", "qualname": "Board_ADS1115.V_oversampchan", "type": "function", "doc": "<p>This routine returns the average voltage for the channel\naveraged at (0.0012 + 1/data_rate)^-1 Hz for avg_sec\nnumber of seconds. The 0.0012 is the required loop time\non a RPI 3B+ in python.</p>\n\n<p>Returns a tuple of the following 5 objects:\n    V_avg -- float, the averaged voltage</p>\n\n<pre><code>V_min -- float, the minimum voltage read during\nthe interval\n\nV_max -- float, the maximum voltage read during the\ninterval\n\ntime_stamp -- float, the time at halfway through the averaging\ninterval in seconds since the beginning of the epoch (OS\ndependent begin time)\n\nself.Vdd -- float, the reference voltage.\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>int chan</strong>:  the channel number (0, 1, 2, 3)</p></li>\n<li><p><strong>gain</strong>:  2/3 (+/-6.144V), 1(+/-4.096V), 2(+/-2.048V),\n4(+/-1.024V), 8 (+/-0.512V), 16 (+/-0.256V))</p></li>\n<li><p><strong>int data_rate</strong>:  the ADC sample rate in Hz (8, 16, 32, 64,\n128,250, 475 or 860 Hz). Set to 475 Hz by default.</p></li>\n<li><p><strong>float avg_sec</strong>:  seconds to average for, actual\naveraging interval will be as close as possible for an integer\nnumber of samples</p></li>\n</ul>\n\n<p>:returns: V_avg, V_min, V_max, time_stamp, self.Vdd</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>description</p>\n</blockquote>\n\n<h6 id=\"returns-2\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-3\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-4\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-5\">Returns</h6>\n", "signature": "(self, chan, gain, avg_sec, data_rate=475)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.ADS1115.Board_ADS1115.V_oversampchan_stats", "modulename": "jupyterpidaq.Boards.PiGPIO.ADS1115", "qualname": "Board_ADS1115.V_oversampchan_stats", "type": "function", "doc": "<p>This routine returns the average voltage for the channel\naveraged at (0.0012 + 1/data_rate)^-1 Hz for avg_sec\nnumber of seconds. The 0.0012 is the required loop time\non a RPI 3B+ in python3. The standard\ndeviation and the estimated deviation of the mean are also\nreturned.</p>\n\n<p>Returns a tuple of the following 5 objects:\n    V_avg -- float, the averaged voltage</p>\n\n<pre><code>stdev -- float, the standard deviation of the measured values\nduring the averaging interval\n\nstdev_avg -- float, the estimated standard deviation of the\nreturned average\n\ntime_stamp -- float, the time at halfway through the averaging\ninterval in seconds since the beginning of the epoch (OS\ndependent begin time)\n\nself.Vdd -- float, the reference voltage.\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>int chan</strong>:  the channel number (0, 1, 2, 3)</p></li>\n<li><p><strong>gain</strong>:  2/3 (+/-6.144V), 1(+/-4.096V), 2(+/-2.048V),\n4(+/-1.024V), 8 (+/-0.512V), 16 (+/-0.256V))</p></li>\n<li><p><strong>int data_rate</strong>:  the ADC sample rate in Hz (8, 16, 32, 64,\n128,250, 475 or 860 Hz). Set to 475 Hz by default.</p></li>\n<li><p><strong>float avg_sec</strong>:  seconds to average for, actual\naveraging interval will be as close as possible for an integer\nnumber of samples</p></li>\n</ul>\n\n<p>:returns: VV_avg, stdev, stdev_avg, time_stamp, self.Vdd</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>description</p>\n</blockquote>\n\n<h6 id=\"returns-2\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-3\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-4\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-5\">Returns</h6>\n", "signature": "(self, chan, gain, avg_sec, data_rate=475)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.ADS1115.Board_ADS1115.V_sampchan", "modulename": "jupyterpidaq.Boards.PiGPIO.ADS1115", "qualname": "Board_ADS1115.V_sampchan", "type": "function", "doc": "<p>This routine returns the voltage for the</p>\n\n<p>Returns a tuple of the following 3 objects:\n    V -- float, the measured voltage</p>\n\n<pre><code>time_stamp -- float, the time at halfway through the averaging\ninterval in seconds since the beginning of the epoch (OS\ndependent begin time)\n\nself.Vdd -- float, the reference voltage.\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>int chan</strong>:  the channel number (0, 1, 2, 3)</p></li>\n<li><p><strong>gain</strong>:  2/3 (+/-6.144V), 1(+/-4.096V), 2(+/-2.048V),\n4(+/-1.024V), 8 (+/-0.512V), 16 (+/-0.256V))</p></li>\n<li><p><strong>int data_rate</strong>:  the ADC sample rate in Hz (8, 16, 32, 64,\n128,250, 475 or 860 Hz). Set to 475 Hz by default.</p></li>\n</ul>\n\n<p>:returns: V, time_stamp, self.Vdd</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-2\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-3\">Returns</h6>\n", "signature": "(self, chan, gain, data_rate=475)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.DAQC2", "modulename": "jupyterpidaq.Boards.PiGPIO.DAQC2", "type": "module", "doc": "<p></p>\n"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.DAQC2.find_boards", "modulename": "jupyterpidaq.Boards.PiGPIO.DAQC2", "qualname": "find_boards", "type": "function", "doc": "<p>A rountine like this must be implemented by all board packages.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of DAQC2 board objects (maximum of 8 boards)</p>\n</blockquote>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.DAQC2.Board_DAQC2", "modulename": "jupyterpidaq.Boards.PiGPIO.DAQC2", "qualname": "Board_DAQC2", "type": "class", "doc": "<p>Class defining the properties of the analog-to-digital block of the\npi-Plates DAQC2 board. Key characteristics:</p>\n\n<ul>\n<li>8 channels (0 - 7) with pseudo 16 bit resolution (oversampled 14 bit) and\na range of +/- 12 V.</li>\n<li>1 channel (8) dedicated to monitoring Vdd.</li>\n<li>Programmable RGB LED to use as indicator.</li>\n<li>Other available facilities are Digital I/O, Digital-to-Analog and\n2-channel o-scope modes. These are not supported by this class.</li>\n</ul>\n", "bases": "jupyterpidaq.Boards.boards.Board"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.DAQC2.Board_DAQC2.__init__", "modulename": "jupyterpidaq.Boards.PiGPIO.DAQC2", "qualname": "Board_DAQC2.__init__", "type": "function", "doc": "<p>Should be overridden by each board and define at minimum:\nself.name = 'board name/adc name/type' Short an useful to end user\nself.vendor = 'Vendor/Manufacturer name`\nself.channels = tuple of available channel IDs\nself.gains = list of gains\nself.Vdd = voltage provided by board to sensors</p>\n", "signature": "(self, addr)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.DAQC2.Board_DAQC2.getsensors", "modulename": "jupyterpidaq.Boards.PiGPIO.DAQC2", "qualname": "Board_DAQC2.getsensors", "type": "function", "doc": "<p>Return a list of valid sensor object names for this board.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of classnames</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.DAQC2.Board_DAQC2.V_oversampchan", "modulename": "jupyterpidaq.Boards.PiGPIO.DAQC2", "qualname": "Board_DAQC2.V_oversampchan", "type": "function", "doc": "<p>This routine returns the average voltage for the channel\naveraged at the default rate for the board and returns an\naverage and observed range.</p>\n\n<p>Returns a tuple of the following 5 objects:\n    V_avg -- float, the averaged voltage</p>\n\n<pre><code>V_min -- float, the minimum voltage read during\nthe interval\n\nV_max -- float, the maximum voltage read during the\ninterval\n\ntime_stamp -- float, the time at halfway through the averaging\ninterval in seconds since the beginning of the epoch (OS\ndependent begin time)\n\nVdd_avg -- float, the reference voltage (Vdd) collected\nsimultaneously.\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>int chan</strong>:  the channel number (0, 1, 2, 3, 4, 5, 6, 7,\n8). NOTE: channel 8 returns a measurement of Vdd.</p></li>\n<li><p><strong>gain</strong>:  ignored by board. Defaults to 1.</p></li>\n<li><p><strong>int data_rate</strong>:  ignored by board.</p></li>\n<li><p><strong>float avg_sec</strong>:  seconds to average for, actual\naveraging interval will be as close as possible for an integer\nnumber of samples</p></li>\n</ul>\n\n<p>:returns: V_avg, V_min, V_max, time_stamp, Vdd_avg</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>description</p>\n</blockquote>\n\n<h6 id=\"returns-2\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-3\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-4\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-5\">Returns</h6>\n", "signature": "(self, chan, gain, avg_sec, data_rate=475)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.DAQC2.Board_DAQC2.V_oversampchan_stats", "modulename": "jupyterpidaq.Boards.PiGPIO.DAQC2", "qualname": "Board_DAQC2.V_oversampchan_stats", "type": "function", "doc": "<p>This routine returns the average voltage for the channel\naveraged at the maximum rate for the board. The standard\ndeviation and the estimated deviation of the mean are also\nreturned.</p>\n\n<p>Returns a tuple of the following 5 objects:\n    V_avg -- float, the averaged voltage</p>\n\n<pre><code>stdev -- float, the standard deviation of the measured values\nduring the averaging interval\n\nstdev_avg -- float, the estimated standard deviation of the\nreturned average\n\ntime_stamp -- float, the time at halfway through the averaging\ninterval in seconds since the beginning of the epoch (OS\ndependent begin time)\n\nVdd_avg -- float, the reference voltage (Vdd) collected\nsimultaneously.\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>int chan</strong>:  the channel number (0, 1, 2, 3, 4, 5, 6, 7,\n8). NOTE: channel 8 returns a measurement of Vdd.</p></li>\n<li><p><strong>gain</strong>:  ignored by board. Defaults to 1.</p></li>\n<li><p><strong>int data_rate</strong>:  ignored by board.</p></li>\n<li><p><strong>float avg_sec</strong>:  seconds to average for, actual\naveraging interval will be as close as possible for an integer\nnumber of samples</p></li>\n</ul>\n\n<p>:returns: V_avg, stdev, stdev_avg, time_stamp, Vdd_avg</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>description</p>\n</blockquote>\n\n<h6 id=\"returns-2\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-3\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-4\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-5\">Returns</h6>\n", "signature": "(self, chan, gain, avg_sec, data_rate=475)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.PiGPIO.DAQC2.Board_DAQC2.V_sampchan", "modulename": "jupyterpidaq.Boards.PiGPIO.DAQC2", "qualname": "Board_DAQC2.V_sampchan", "type": "function", "doc": "<p>This routine returns a single reading of the voltage for the channel.</p>\n\n<p>Returns a tuple of the following 5 objects:\n    V -- float, the measured voltage</p>\n\n<pre><code>time_stamp -- float, the time of the measurement in seconds since\nthe beginning of the epoch (OS dependent begin time)\n\nref -- float, the reference voltage (Vdd) collected\nsimultaneously.\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>int chan</strong>:  the channel number (0, 1, 2, 3, 4, 5, 6, 7,\n8). NOTE: channel 8 returns a measurement of Vdd.</p></li>\n<li><p><strong>gain</strong>:  ignored by board. Defaults to 1.</p></li>\n<li><p><strong>int data_rate</strong>:  ignored by board.</p></li>\n</ul>\n\n<p>:returns: V_avg, stdev, stdev_avg, time_stamp, Vdd_avg</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-2\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<h6 id=\"returns-3\">Returns</h6>\n", "signature": "(self, chan, gain, data_rate=475)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated", "modulename": "jupyterpidaq.Boards.Simulated", "type": "module", "doc": "<p>This module wraps modules for simulated boards.</p>\n"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim", "type": "module", "doc": "<p></p>\n"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim.find_boards", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim", "qualname": "find_boards", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim.Board_ADCsim_random", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim", "qualname": "Board_ADCsim_random", "type": "class", "doc": "<p>Base class for all boards. Each board should be an extension of this class.</p>\n", "bases": "jupyterpidaq.Boards.boards.Board"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim.Board_ADCsim_random.__init__", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim", "qualname": "Board_ADCsim_random.__init__", "type": "function", "doc": "<p>Should be overridden by each board and define at minimum:\nself.name = 'board name/adc name/type' Short an useful to end user\nself.vendor = 'Vendor/Manufacturer name`\nself.channels = tuple of available channel IDs\nself.gains = list of gains\nself.Vdd = voltage provided by board to sensors</p>\n", "signature": "(self, adc)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim.Board_ADCsim_random.getsensors", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim", "qualname": "Board_ADCsim_random.getsensors", "type": "function", "doc": "<p>Return a list of valid sensor object names for this board.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of classnames</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim.Board_ADCsim_random.V_oversampchan_stats", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim", "qualname": "Board_ADCsim_random.V_oversampchan_stats", "type": "function", "doc": "<p>This routine returns the average voltage for the channel\naveraged at (0.0012 + 1/data_rate)^-1 Hz for avg_sec\nnumber of seconds. The 0.0012 is the required loop time\non a RPI 3B+ in python3. The voltage is rounded to the number\nof decimals indicated by the standard deviation. The standard\ndeviation and the estimated deviation of the mean are also\nreturned.\nParameters\n    chan    the channel number 0, 1, 2, 3\n    gain    2/3 (+/-6.144V), 1(+/-4.096V), 2(+/-2.048V), 4(+/-1.024V),\n            8 (+/-0.512V), 16 (+/-0.256V)\n    data_rate the ADC sample rate in Hz (8, 16, 32, 64, 128, 250, 475 or 860 Hz)\n    avg_sec seconds to average for, actual averaging interval will be as close\n            as possible for an integer number of samples.\nReturns a tuple (V_avg, V_min, V_max, time_stamp)\n    V_avg   the averaged voltage\n    stdev   estimated standard deviation of the measurements\n    stdev_avg   estimated standard deviation of the mean\n    time_stamp the time at halfway through the averaging interval in seconds\n            since the beginning of the epoch (OS dependent begin time).</p>\n", "signature": "(self, chan, gain, avg_sec, data_rate=475)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim.Board_ADCsim_random.V_oversampchan", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim", "qualname": "Board_ADCsim_random.V_oversampchan", "type": "function", "doc": "<p>This routine returns the average voltage for the channel\naveraged at (0.0012 + 1/data_rate)^-1 Hz for avg_sec\nnumber of seconds. The 0.0012 is the required loop time\non a RPI 3B+ in python3. The voltage is rounded to the number\nof decimals indicated by the standard deviation. The standard\ndeviation and the estimated deviation of the mean are also\nreturned.\nParameters\n    chan    the channel number 0, 1, 2, 3\n    gain    2/3 (+/-6.144V), 1(+/-4.096V), 2(+/-2.048V), 4(+/-1.024V),\n            8 (+/-0.512V), 16 (+/-0.256V)\n    data_rate the ADC sample rate in Hz (8, 16, 32, 64, 128, 250, 475 or 860 Hz)\n    avg_sec seconds to average for, actual averaging interval will be as close\n            as possible for an integer number of samples.\nReturns a tuple (V_avg, V_min, V_max, time_stamp)\n    V_avg   the averaged voltage\n    stdev   estimated standard deviation of the measurements\n    stdev_avg   estimated standard deviation of the mean\n    time_stamp the time at halfway through the averaging interval in seconds\n            since the beginning of the epoch (OS dependent begin time).</p>\n", "signature": "(self, chan, gain, avg_sec, data_rate=475)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim.Board_ADCsim_random.V_sampchan", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim", "qualname": "Board_ADCsim_random.V_sampchan", "type": "function", "doc": "<p>This function returns a single measurement and the time it was\ncollected.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>chan</strong>:  id of the channel to be measured</li>\n<li><strong>gain</strong>:  gain of the channel if adjustable</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a tuple consisting of V, time_stamp, where V = the single\n  voltage measurement and time_stamp the time it was collected.</p>\n</blockquote>\n", "signature": "(self, chan, gain, **kwargs)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim_line", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim_line", "type": "module", "doc": "<p></p>\n"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim_line.find_boards", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim_line", "qualname": "find_boards", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim_line.Board_ADCsim_line", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim_line", "qualname": "Board_ADCsim_line", "type": "class", "doc": "<p>This class simulates an Analog-to-Digital board that returns a linearly\nincreasing signal with a small amount of noise on the signal. The\nintercept and slope depend upon which hour of the day the simulation is\nrun.</p>\n", "bases": "jupyterpidaq.Boards.boards.Board"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim_line.Board_ADCsim_line.__init__", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim_line", "qualname": "Board_ADCsim_line.__init__", "type": "function", "doc": "<p>Should be overridden by each board and define at minimum:\nself.name = 'board name/adc name/type' Short an useful to end user\nself.vendor = 'Vendor/Manufacturer name`\nself.channels = tuple of available channel IDs\nself.gains = list of gains\nself.Vdd = voltage provided by board to sensors</p>\n", "signature": "(self, adc)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim_line.Board_ADCsim_line.getsensors", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim_line", "qualname": "Board_ADCsim_line.getsensors", "type": "function", "doc": "<p>Return a list of valid sensor object names for this board.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of classnames</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim_line.Board_ADCsim_line.V_oversampchan", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim_line", "qualname": "Board_ADCsim_line.V_oversampchan", "type": "function", "doc": "<p>This routine returns the average voltage for the channel\naveraged at (0.0012 + 1/data_rate)^-1 Hz for avg_sec\nnumber of seconds. The 0.0012 is the required loop time\non a RPI 3B+ in python3. The voltage is rounded to the number\nof decimals indicated by the standard deviation. The standard\ndeviation and the estimated deviation of the mean are also\nreturned.\nParameters\n    chan    the channel number 0, 1, 2, 3\n    gain    2/3 (+/-6.144V), 1(+/-4.096V), 2(+/-2.048V), 4(+/-1.024V),\n            8 (+/-0.512V), 16 (+/-0.256V)\n    data_rate the ADC sample rate in Hz (8, 16, 32, 64, 128, 250, 475\n     or 860 Hz)\n    avg_sec seconds to average for, actual averaging interval will be\n     as close as possible for an integer number of samples.\nReturns a tuple (V_avg, V_min, V_max, time_stamp)\n    V_avg   the averaged voltage\n    stdev   estimated standard deviation of the measurements\n    stdev_avg   estimated standard deviation of the mean\n    time_stamp the time at halfway through the averaging interval in\n     seconds since the beginning of the epoch (OS dependent begin\n     time).</p>\n", "signature": "(self, chan, gain, avg_sec, data_rate=475)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim_line.Board_ADCsim_line.V_oversampchan_stats", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim_line", "qualname": "Board_ADCsim_line.V_oversampchan_stats", "type": "function", "doc": "<p>This routine returns the average voltage for the channel\naveraged at (0.0012 + 1/data_rate)^-1 Hz for avg_sec\nnumber of seconds. The 0.0012 is the required loop time\non a RPI 3B+ in python3. The voltage is rounded to the number\nof decimals indicated by the standard deviation. The standard\ndeviation and the estimated deviation of the mean are also\nreturned.\nParameters\n    chan    the channel number 0, 1, 2, 3\n    gain    2/3 (+/-6.144V), 1(+/-4.096V), 2(+/-2.048V), 4(+/-1.024V),\n            8 (+/-0.512V), 16 (+/-0.256V)\n    data_rate the ADC sample rate in Hz (8, 16, 32, 64, 128, 250, 475\n     or 860 Hz)\n    avg_sec seconds to average for, actual averaging interval will be\n     as close as possible for an integer number of samples.\nReturns a tuple (V_avg, V_min, V_max, time_stamp)\n    V_avg   the averaged voltage\n    stdev   estimated standard deviation of the measurements\n    stdev_avg   estimated standard deviation of the mean\n    time_stamp the time at halfway through the averaging interval in\n      seconds since the beginning of the epoch (OS dependent begin\n      time).</p>\n", "signature": "(self, chan, gain, avg_sec, data_rate=475)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.Simulated.ADCsim_line.Board_ADCsim_line.V_sampchan", "modulename": "jupyterpidaq.Boards.Simulated.ADCsim_line", "qualname": "Board_ADCsim_line.V_sampchan", "type": "function", "doc": "<p>This routine returns the average voltage for the channel\naveraged at (0.0012 + 1/data_rate)^-1 Hz for avg_sec\nnumber of seconds. The 0.0012 is the required loop time\non a RPI 3B+ in python3. The voltage is rounded to the number\nof decimals indicated by the standard deviation. The standard\ndeviation and the estimated deviation of the mean are also\nreturned.\nParameters\n    chan    the channel number 0, 1, 2, 3\n    gain    2/3 (+/-6.144V), 1(+/-4.096V), 2(+/-2.048V), 4(+/-1.024V),\n            8 (+/-0.512V), 16 (+/-0.256V)\n    data_rate the ADC sample rate in Hz (8, 16, 32, 64, 128, 250, 475\n     or 860 Hz) avg_sec seconds to average for, actual averaging\n     interval will be as close as possible for an integer number of\n     samples.\nReturns a tuple (V_avg, V_min, V_max, time_stamp)\n    V_avg   the averaged voltage\n    stdev   estimated standard deviation of the measurements\n    stdev_avg   estimated standard deviation of the mean\n    time_stamp the time at halfway through the averaging interval in\n     seconds since the beginning of the epoch (OS dependent begin\n     time).</p>\n", "signature": "(self, chan, gain, data_rate=475)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards", "modulename": "jupyterpidaq.Boards.boards", "type": "module", "doc": "<p>This file handles loading adc board control software and sensor information.\nIt uses the list of known boards. It will skip boards that produce an error\neither because the pypi package is not installed or an error occurs when\ntrying to communicate with the board.</p>\n\n<p>The ADC simulator will be installed if no boards are available.</p>\n"}, {"fullname": "jupyterpidaq.Boards.boards.load_boards", "modulename": "jupyterpidaq.Boards.boards", "qualname": "load_boards", "type": "function", "doc": "<p>Uses the list of known board packages to search for available boards.\nThe file <boardname>.py should at minimum\nimplement a <code>find_boards(): routine that overrides the function below and\ndefine a class for the particular board that extends the</code>Board` class\ndefined below.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of adc board objects.</p>\n</blockquote>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards.find_boards", "modulename": "jupyterpidaq.Boards.boards", "qualname": "find_boards", "type": "function", "doc": "<p>A function overriding this must be implemented by all board packages.\nSee examples in working packages. This is highly board dependent.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of board objects</p>\n</blockquote>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards.Board", "modulename": "jupyterpidaq.Boards.boards", "qualname": "Board", "type": "class", "doc": "<p>Base class for all boards. Each board should be an extension of this class.</p>\n"}, {"fullname": "jupyterpidaq.Boards.boards.Board.__init__", "modulename": "jupyterpidaq.Boards.boards", "qualname": "Board.__init__", "type": "function", "doc": "<p>Should be overridden by each board and define at minimum:\nself.name = 'board name/adc name/type' Short an useful to end user\nself.vendor = 'Vendor/Manufacturer name`\nself.channels = tuple of available channel IDs\nself.gains = list of gains\nself.Vdd = voltage provided by board to sensors</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards.Board.getname", "modulename": "jupyterpidaq.Boards.boards", "qualname": "Board.getname", "type": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>string value of the board name, a short label of board type.</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards.Board.getchannels", "modulename": "jupyterpidaq.Boards.boards", "qualname": "Board.getchannels", "type": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>tuple of ids for available channels</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards.Board.getgains", "modulename": "jupyterpidaq.Boards.boards", "qualname": "Board.getgains", "type": "function", "doc": "<p>If not defined for a specific board the gain is fixed at 1.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>tuple of gains availabe for onboard preamp</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards.Board.getvendor", "modulename": "jupyterpidaq.Boards.boards", "qualname": "Board.getvendor", "type": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>string value of the vendor name</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards.Board.getVdd", "modulename": "jupyterpidaq.Boards.boards", "qualname": "Board.getVdd", "type": "function", "doc": "<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>numerical value of the Vdd, voltage provided to sensors</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards.Board.getsensors", "modulename": "jupyterpidaq.Boards.boards", "qualname": "Board.getsensors", "type": "function", "doc": "<p>This returns a list of objects that allow the software to translate\nthe measured voltage into a sensor reading in appropriate units.\nMust be provided by the specific board implementation. See examples\nin working board packages.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A list of valid sensor objects to use with this board. This\n  should be a subset of all the sensors returned by the listSensors\n  function in sensors.py.</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards.Board.V_oversampchan", "modulename": "jupyterpidaq.Boards.boards", "qualname": "Board.V_oversampchan", "type": "function", "doc": "<p>This function should return a tuple with average, minimum and maximum\nfor a channel averaged over the period of time avg_sec. How the\naveraging is performed will depend on the board.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>chan</strong>:  id of the channel to be measured</li>\n<li><strong>gain</strong>:  gain of the channel if adjustable</li>\n<li><strong>avg_sec</strong>:  float period of time over which to average</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a tuple consisting of V_avg, V_min, V_max, time_stamp, avg_Vdd\n      The time_stamp is the time the data was collected, usually the\n      middle of the averaging period. avg_Vdd should be the measured\n      average Vdd taken simultaneously, immediately before,\n      or immediately after the voltage being measured. If the board or\n      power supply is very stable self.Vdd can be returned instead.</p>\n</blockquote>\n", "signature": "(self, chan, gain, avg_sec, **kwargs)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards.Board.V_oversampchan_stats", "modulename": "jupyterpidaq.Boards.boards", "qualname": "Board.V_oversampchan_stats", "type": "function", "doc": "<p>This function should return a tuple of statistical information for a\nchannel averaged over the period of time avg_sec.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>chan</strong>:  id of the channel to be measured</li>\n<li><strong>gain</strong>:  gain of the channel if adjustable</li>\n<li><strong>avg_sec</strong>:  float period of time over which to average</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>tuple consisting of V_avg, stdev, stdev_avg, time_stamp,\n      avg_Vdd where stdev_avg is the estimated standard deviation\n      of the average not the standard deviation of the values\n      sampled (stdev). avg_Vdd should be the measured\n      average Vdd taken simultaneously, immediately before,\n      or immediately after the voltage being measured. If the board or\n      power supply is very stable self.Vdd can be returned instead.</p>\n</blockquote>\n", "signature": "(self, chan, gain, avg_sec, **kwargs)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Boards.boards.Board.V_sampchan", "modulename": "jupyterpidaq.Boards.boards", "qualname": "Board.V_sampchan", "type": "function", "doc": "<p>This function returns a single measurement and the time it was\ncollected.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>chan</strong>:  id of the channel to be measured</li>\n<li><strong>gain</strong>:  gain of the channel if adjustable</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a tuple consisting of V, time_stamp, ref_Vdd, where V = the\n      single voltage measurement and time_stamp the time it was\n      collected. ref_Vdd should be the measured\n      Vdd taken simultaneously, immediately before,\n      or immediately after the voltage being measured. If the board or\n      power supply is very stable self.Vdd can be returned instead.</p>\n</blockquote>\n", "signature": "(self, chan, gain, **kwargs)", "funcdef": "def"}, {"fullname": "jupyterpidaq.ChannelSettings", "modulename": "jupyterpidaq.ChannelSettings", "type": "module", "doc": "<p></p>\n"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings", "type": "class", "doc": "<p>This class takes care of interacting with the user to get settings for data\ncollection on each channel. Should be initialized with an idno, so that\nit knows what number has been assigned to it.</p>\n"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings.__init__", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings.__init__", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>idno</strong>:  int number iding this instance of ChannelSettings</li>\n</ul>\n", "signature": "(self, idno, availboards)", "funcdef": "def"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings.activate", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings.activate", "type": "function", "doc": "<p>This function makes this channel active. No return value unless an e\nrror is thrown by something called by this function.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings.deactivate", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings.deactivate", "type": "function", "doc": "<p>This function makes the channel inactive. No return value unless an\nerror is thrown by something called by this function.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings.checkchanged", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings.checkchanged", "type": "function", "doc": "<p>This function is called when the checkbox changes.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>self</strong>: </li>\n<li><strong>change</strong>:  change object passed by the observe tool</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self, change)", "funcdef": "def"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings.boardchanged", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings.boardchanged", "type": "function", "doc": "<p>This function responds to a change in board choice.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>change</strong>:  change object passed by the observe tool</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "(self, change)", "funcdef": "def"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings.channelchanged", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings.channelchanged", "type": "function", "doc": "<p>This function responds to a change in board choice.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>change</strong>:  change object passed by the observe tool</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "(self, change)", "funcdef": "def"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings.sensorchanged", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings.sensorchanged", "type": "function", "doc": "<p>Called  by the observe function of sensorchoice when the user changes\nthe sensor choice.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>self</strong>: </li>\n<li><strong>change</strong>:  change object passed by the observe tool</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self, change)", "funcdef": "def"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings.unitschanged", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings.unitschanged", "type": "function", "doc": "<p>Called by the observe function for the units selector when units are\nchanged</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>self</strong>: </li>\n<li><strong>change</strong>:  change object passed by the observe tool</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "(self, change)", "funcdef": "def"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings.gainschanged", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings.gainschanged", "type": "function", "doc": "<p>Called by the observe function for the gains selector when the gain is\nchanged.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>self</strong>: </li>\n<li><strong>change</strong>:  change object passed by the observe tool</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "(self, change)", "funcdef": "def"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings.setup", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings.setup", "type": "function", "doc": "<p>Sets up the GUI and the necessary monitoring.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.ChannelSettings.ChannelSettings.hideGUI", "modulename": "jupyterpidaq.ChannelSettings", "qualname": "ChannelSettings.hideGUI", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQProc", "modulename": "jupyterpidaq.DAQProc", "type": "module", "doc": "<p></p>\n"}, {"fullname": "jupyterpidaq.DAQProc.DAQProc", "modulename": "jupyterpidaq.DAQProc", "qualname": "DAQProc", "type": "function", "doc": "<p>This function is to be run in a separate thread to asynchronously\ncommunicate with the ADC board.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>list whichchn</strong>:  a list of dictionaries. Each dictionary is of the\nform:{'board': board_object, 'chnl': chnlID}.</p></li>\n<li><p><strong>list gains</strong>:  a list of the numerical gain for each channel.</p></li>\n<li><p><strong>float avgtime</strong>:  the averaging time in seconds for a data point.</p></li>\n<li><p><strong>float timedelta</strong>:  the target time between data points.</p></li>\n<li><p><strong>pipe DAQconn</strong>:  the connection pipe</p></li>\n<li><p><strong>pipe DAQCTL</strong>:  the control pipe</p></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Data is returned via the pipes.\n      On the DAQCTL pipe this only returns 'done'\n      On the DAQconn pipe a list of lists with data is returned.</p>\n</blockquote>\n", "signature": "(whichchn, gains, avgtime, timedelta, DAQconn, DAQCTL)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance", "modulename": "jupyterpidaq.DAQinstance", "type": "module", "doc": "<p></p>\n"}, {"fullname": "jupyterpidaq.DAQinstance.DAQinstance", "modulename": "jupyterpidaq.DAQinstance", "qualname": "DAQinstance", "type": "class", "doc": "<p></p>\n"}, {"fullname": "jupyterpidaq.DAQinstance.DAQinstance.__init__", "modulename": "jupyterpidaq.DAQinstance", "qualname": "DAQinstance.__init__", "type": "function", "doc": "<p>Data Aquistion Instance (a run).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>idno</strong>:  id number you wish to use to keep track</li>\n<li><strong>livefig</strong>:  plotly FigureWidget to use for live display</li>\n<li><strong>title</strong>:  optional name</li>\n<li><strong>ntraces</strong>:  number of traces (default = 4) more than 4 easily\noverwhelms a pi4.</li>\n<li><strong>kwargs</strong>: \n:ignore_skew: bool (default: True) if True only a single average\ncollection time will be recorded for each time in a multichannel\ndata collection. If False a separate set of time will be\nrecorded for each channel.</li>\n</ul>\n", "signature": "(self, idno, livefig, title='None', ntraces=4, **kwargs)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.DAQinstance.setupclick", "modulename": "jupyterpidaq.DAQinstance", "qualname": "DAQinstance.setupclick", "type": "function", "doc": "<p></p>\n", "signature": "(self, btn)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.DAQinstance.setup", "modulename": "jupyterpidaq.DAQinstance", "qualname": "DAQinstance.setup", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.DAQinstance.collectclick", "modulename": "jupyterpidaq.DAQinstance", "qualname": "DAQinstance.collectclick", "type": "function", "doc": "<p></p>\n", "signature": "(self, btn)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.DAQinstance.fillpandadf", "modulename": "jupyterpidaq.DAQinstance", "qualname": "DAQinstance.fillpandadf", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.DAQinstance.updatingplot", "modulename": "jupyterpidaq.DAQinstance", "qualname": "DAQinstance.updatingplot", "type": "function", "doc": "<p>Runs until a check of self.collectbtn.description does not return\n'Stop Collecting'. This would probably be more efficient if set a\nboolean.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.newRun", "modulename": "jupyterpidaq.DAQinstance", "qualname": "newRun", "type": "function", "doc": "<p>Set up a new data collection run and add it to the list of runs.</p>\n", "signature": "(livefig)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.doRun", "modulename": "jupyterpidaq.DAQinstance", "qualname": "doRun", "type": "function", "doc": "<p></p>\n", "signature": "(whichrun)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.displayRun", "modulename": "jupyterpidaq.DAQinstance", "qualname": "displayRun", "type": "function", "doc": "<p>Displays a run. It can fall back to loading from a file if the outputarea\nis accidentally cleared.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>runidx</strong>:  index+1 for the run in the runs array. Thus, the run id #.</li>\n<li><strong>file</strong>:  name of the file the run is saved to</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A string warning if things are not initialized properly.</p>\n</blockquote>\n", "signature": "(runidx, file)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.update_runsdrp", "modulename": "jupyterpidaq.DAQinstance", "qualname": "update_runsdrp", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.showSelectedRunTable", "modulename": "jupyterpidaq.DAQinstance", "qualname": "showSelectedRunTable", "type": "function", "doc": "<p></p>\n", "signature": "(change)", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.showDataTable", "modulename": "jupyterpidaq.DAQinstance", "qualname": "showDataTable", "type": "function", "doc": "<p>Provides a menu to select which run. Then displays the run in a\n10 em high scrolling table. Selection menu is removed after choice\nis made.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.newCalculatedColumn", "modulename": "jupyterpidaq.DAQinstance", "qualname": "newCalculatedColumn", "type": "function", "doc": "<p>Uses jupyter-pandas-GUI.new_pandas_column_GUI to provide a GUI expression\ncomposer. This method finds the datasets and launches the GUI.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.newPlot", "modulename": "jupyterpidaq.DAQinstance", "qualname": "newPlot", "type": "function", "doc": "<p>Uses jupyter-pandas-GUI.plot_pandas_GUI to provide a GUI expression\ncomposer. This method finds the datasets and launches the GUI.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.DAQinstance.newFit", "modulename": "jupyterpidaq.DAQinstance", "qualname": "newFit", "type": "function", "doc": "<p>Uses jupyter-pandas-GUI.fit_pandas_GUI to provide a GUI expression\ncomposer. This method finds the datasets and launches the GUI.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors", "modulename": "jupyterpidaq.Sensors", "type": "module", "doc": "<p>This module wraps all the modules related to interpretting data from known\nsensors.</p>\n"}, {"fullname": "jupyterpidaq.Sensors.sensors", "modulename": "jupyterpidaq.Sensors.sensors", "type": "module", "doc": "<p></p>\n"}, {"fullname": "jupyterpidaq.Sensors.sensors.to_reasonable_significant_figures", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "to_reasonable_significant_figures", "type": "function", "doc": "<p>This function will return value rounded to a reasonable number of\nsignificant figures based on the uncertainty. If you are doing this\nbased on the standard return from the raw voltage or the sensor\ndefinitions in this file it is recommend that this be the standard\ndeviation of the average, which will often provide about one more digit\nthan the standard deviation. This will provide a guard digit for further\ncomputations.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float value</strong>:  the value to be rounded</li>\n<li><strong>float uncertainty</strong>:  the uncertainty.</li>\n</ul>\n\n<p>:returns float:</p>\n\n<p>Returns: rounded_value a floating point number.</p>\n", "signature": "(value, uncertainty)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.to_reasonable_significant_figures_fast", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "to_reasonable_significant_figures_fast", "type": "function", "doc": "<p>This function will return values rounded to a reasonable number of\nsignificant figures based on the avg_std. This function requires fewer\ncompares so is a little more efficient than calling\nto_reasonable_significant_figures(value, uncertainty) for avg, std,\navg_std separately.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float avg</strong>:  the average value</li>\n<li><strong>float std</strong>:  the standard deviation</li>\n<li><strong>float avg_std</strong>:  the estimated standard deviation in avg\n:returns list:</li>\n</ul>\n\n<p>Returns: list of rounded values for each [avg, std, avg_std]</p>\n", "signature": "(avg, std, avg_std)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.listSensors", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "listSensors", "type": "function", "doc": "<p>Provides a list of the sensor classes provided by this file. The list must\nbe manually updated with each new class.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list of classnames</p>\n</blockquote>\n", "signature": "()", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.RawAtoD", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "RawAtoD", "type": "class", "doc": "<p>This is the base sensor class which all sensors should extend. See how to\ndo this properly using one of the examples below.\nThis class contains definitions for the raw AtoD return in volts. The\ndigital values are not used as the AtoD may have a builtin pre-amp,\nso a given digital value has different meanings depending upon the pre-amp\nsetting.</p>\n"}, {"fullname": "jupyterpidaq.Sensors.sensors.RawAtoD.__init__", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "RawAtoD.__init__", "type": "function", "doc": "<p>This init should be called first in the init section of any class\nextending this class (e.g. <code>super().__init__(Vdd)</code>). Then set\n<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units\nspecific to the sensor to <code>self.units</code>. The parameter Vdd must be\nsupplied upon initialization because the output voltage of some\nsensors depends on Vdd.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float Vdd</strong>:  the voltage supplied to the sensor by the A-to-D\nboard in case the sensor output depends on this.</li>\n</ul>\n", "signature": "(self, Vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.RawAtoD.getname", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "RawAtoD.getname", "type": "function", "doc": "<p>Provides a string name for the sensor</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>string containing the sensor name</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.RawAtoD.getvendor", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "RawAtoD.getvendor", "type": "function", "doc": "<p>Provides a string name for the sensor vendor/manufacturer</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>string containing the vendor/manufacturer name</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.RawAtoD.getunits", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "RawAtoD.getunits", "type": "function", "doc": "<p>Provides the string names for the available units for this sensor.\nThese string names are also the functions within this class that\nreturn the measurement in those units.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>units a list of strings.</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.RawAtoD.V", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "RawAtoD.V", "type": "function", "doc": "<p>It is not really necessary to call this function because it just\nreturns the same values that are passed to it.\nIt is provided for consistency with the way sensors units are defined.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>v_avg: v_avg</strong>:  average voltage from A-to-D</li>\n<li><strong>v_std</strong>:  standard deviation of the A-to-D measurements</li>\n<li><strong>avg_std</strong>:  estimate of the standard deviation of v_avg</li>\n<li><strong>float avg_vdd</strong>:  simultaneously measured average Vdd.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>[v_avg, v_std, avg_std]</p>\n</blockquote>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.RawAtoD.mV", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "RawAtoD.mV", "type": "function", "doc": "<p>Convert the raw AtoD voltage to mV.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>v_avg: v_avg</strong>:  average voltage from A-to-D</li>\n<li><strong>v_std</strong>:  standard deviation of the A-to-D measurements</li>\n<li><strong>avg_std</strong>:  estimate of the standard deviation of v_avg</li>\n<li><strong>float avg_vdd</strong>:  simultaneously measured average Vdd.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>[v_avg, v_std, avg_std] converted to mV</p>\n</blockquote>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.BuiltInThermistor", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "BuiltInThermistor", "type": "class", "doc": "<p>This class contains the definitions for builtin thermistor.</p>\n", "bases": "RawAtoD"}, {"fullname": "jupyterpidaq.Sensors.sensors.BuiltInThermistor.__init__", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "BuiltInThermistor.__init__", "type": "function", "doc": "<p>This init should be called first in the init section of any class\nextending this class (e.g. <code>super().__init__(Vdd)</code>). Then set\n<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units\nspecific to the sensor to <code>self.units</code>. The parameter Vdd must be\nsupplied upon initialization because the output voltage of some\nsensors depends on Vdd.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float Vdd</strong>:  the voltage supplied to the sensor by the A-to-D\nboard in case the sensor output depends on this.</li>\n</ul>\n", "signature": "(self, Vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.BuiltInThermistor.K", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "BuiltInThermistor.K", "type": "function", "doc": "<p>The returned values are in K. It is assumed that the distribution is\nsymmetric guassian even in K. This may not be true, but still gives\na reasonable estimate of the standard deviation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>v_avg</strong>:  average voltage from sensor.</li>\n<li><strong>v_std</strong>:  standard deviation of voltage from sensor.</li>\n<li><strong>avg_std</strong>:  estimated standard deviation of the avg.</li>\n<li><strong>float avg_vdd</strong>:  simultaneously measured average Vdd.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: list [K_avg, K_std, K_avg_std]\n [average temperature in K,\n standard deviation of temperature in K,\n estimated standard deviation of the average temperature].</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.BuiltInThermistor.C", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "BuiltInThermistor.C", "type": "function", "doc": "<p>The returned values are in deg C. It is assumed that the distribution\nis symmetric guassian even in deg C. This may not be true, but still\ngives a reasonable estimate of the standard deviation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>v_avg</strong>:  average voltage from sensor.</li>\n<li><strong>v_std</strong>:  standard deviation of voltage from sensor.</li>\n<li><strong>avg_std</strong>:  estimated standard deviation of the avg.</li>\n<li><strong>float avg_vdd</strong>:  simultaneously measured average Vdd.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: list [C_avg, C_std, C_avg_std]\n [average temperature in C, standard deviation of temperature in C,\n    estimated standard deviation of the average temperature].</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.BuiltInThermistor.F", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "BuiltInThermistor.F", "type": "function", "doc": "<p>The returned values are in deg F. It is assumed that the distribution\nis symmetric guassian even in deg F. This may not be true, but still\ngives a reasonable estimate of the standard deviation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average voltage from sensor.</li>\n<li><strong>float v_std</strong>:  standard deviation of voltage from sensor.</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of the avg.</li>\n<li><strong>float avg_vdd</strong>:  simultaneously measured average Vdd.\n:returns list:</li>\n</ul>\n\n<p>Returns: list [F_avg, F_std, F_avg_std]\n [average temperature in F, standard deviation of temperature in F,\n estimated standard deviation of the average temperature].</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierSSTemp", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierSSTemp", "type": "class", "doc": "<p>This class contains the definitions for Vernier Stainless Steel Temperature\nProbe. A 20K thermistor.</p>\n", "bases": "RawAtoD"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierSSTemp.__init__", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierSSTemp.__init__", "type": "function", "doc": "<p>This init should be called first in the init section of any class\nextending this class (e.g. <code>super().__init__(Vdd)</code>). Then set\n<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units\nspecific to the sensor to <code>self.units</code>. The parameter Vdd must be\nsupplied upon initialization because the output voltage of some\nsensors depends on Vdd.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float Vdd</strong>:  the voltage supplied to the sensor by the A-to-D\nboard in case the sensor output depends on this.</li>\n</ul>\n", "signature": "(self, Vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierSSTemp.K", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierSSTemp.K", "type": "function", "doc": "<p>The returned values are in K. It is assumed that the distribution is\nsymmetric guassian even in K. This may not be true, but still gives\na reasonable estimate of the standard deviation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average voltage from sensor.</li>\n<li><strong>float v_std</strong>:  standard deviation of voltage from sensor.</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of the avg.</li>\n<li><strong>float avg_vdd</strong>:  simultaneously measured average Vdd.\n:returns list:</li>\n</ul>\n\n<p>Returns list [K_avg, K_std, K_avg_std]\n [average temperature in K, standard deviation of temperature in K,\n estimated standard deviation of the average temperature].</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierSSTemp.C", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierSSTemp.C", "type": "function", "doc": "<p>The returned values are in deg C. It is assumed that the distribution\nis symmetric guassian even in deg C. This may not be true, but still\ngives a reasonable estimate of the standard deviation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average voltage from sensor.</li>\n<li><strong>float v_std</strong>:  standard deviation of voltage from sensor.</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of the avg.</li>\n<li><strong>float avg_vdd</strong>:  simultaneously measured average Vdd.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: C_avg, C_std, C_avg_std\n average temperature in C, standard deviation of temperature in C,\n estimated standard deviation of the average temperature.</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierSSTemp.F", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierSSTemp.F", "type": "function", "doc": "<p>The returned values are in deg F. It is assumed that the\ndistribution is symmetric guassian even in deg F. This may not be\ntrue, but still gives a reasonable estimate of the standard\ndeviation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average voltage from sensor.</li>\n<li><strong>float v_std</strong>:  standard deviation of voltage from sensor.</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of the avg.</li>\n<li><strong>float avg_vdd</strong>:  simultaneously measured average Vdd.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: F_avg, F_std, F_avg_std\n average temperature in F, standard deviation of\n temperature in F, estimated standard deviation of the average\n temperature.</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP", "type": "class", "doc": "<p>This class contains the definitions for Vernier absolute gas pressure\nsensor, GPS-BTA (post 2011 manufacture).</p>\n", "bases": "RawAtoD"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP.__init__", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP.__init__", "type": "function", "doc": "<p>This init should be called first in the init section of any class\nextending this class (e.g. <code>super().__init__(Vdd)</code>). Then set\n<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units\nspecific to the sensor to <code>self.units</code>. The parameter Vdd must be\nsupplied upon initialization because the output voltage of some\nsensors depends on Vdd.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float Vdd</strong>:  the voltage supplied to the sensor by the A-to-D\nboard in case the sensor output depends on this.</li>\n</ul>\n", "signature": "(self, Vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP.Pa", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP.Pa", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the raw voltage</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of v_avg</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (not\nused)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in Pascals</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP.kPa", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP.kPa", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the raw voltage</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of v_avg</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (not\nused)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in kiloPascals</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP.Bar", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP.Bar", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the raw voltage</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of v_avg</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (not\nused)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in Bars</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP.Torr", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP.Torr", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the voltage measurements</li>\n<li><strong>float avg_std</strong>:  estimate of the standard deviation of the average</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (\nnot used)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in Torr</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP.mmHg", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP.mmHg", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the voltage measurements</li>\n<li><strong>float avg_std</strong>:  estimate of the standard deviation of the average</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (\nnot used)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in mmHg</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP.atm", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP.atm", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the voltage measurements</li>\n<li><strong>float avg_std</strong>:  estimate of the standard deviation of the average</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (\nnot used)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in atm</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP_OLD", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP_OLD", "type": "class", "doc": "<p>This class contains the definitions for Vernier absolute gas pressure\nsensor, GPS-BTA (pre 2011 manufacture. Label does not depict a caliper\nwith the registered trademark symbol).</p>\n", "bases": "RawAtoD"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP_OLD.__init__", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP_OLD.__init__", "type": "function", "doc": "<p>This init should be called first in the init section of any class\nextending this class (e.g. <code>super().__init__(Vdd)</code>). Then set\n<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units\nspecific to the sensor to <code>self.units</code>. The parameter Vdd must be\nsupplied upon initialization because the output voltage of some\nsensors depends on Vdd.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float Vdd</strong>:  the voltage supplied to the sensor by the A-to-D\nboard in case the sensor output depends on this.</li>\n</ul>\n", "signature": "(self, Vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP_OLD.Pa", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP_OLD.Pa", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the raw voltage</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of v_avg</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (not\nused)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in Pascals</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP_OLD.kPa", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP_OLD.kPa", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the raw voltage</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of v_avg</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (not\nused)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in kiloPascals</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP_OLD.Bar", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP_OLD.Bar", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the raw voltage</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of v_avg</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (not\nused)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in Bars</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP_OLD.Torr", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP_OLD.Torr", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the voltage measurements</li>\n<li><strong>float avg_std</strong>:  estimate of the standard deviation of the average</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (\nnot used)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in Torr</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP_OLD.mmHg", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP_OLD.mmHg", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the voltage measurements</li>\n<li><strong>float avg_std</strong>:  estimate of the standard deviation of the average</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (\nnot used)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in mmHg</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierGasP_OLD.atm", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierGasP_OLD.atm", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the voltage measurements</li>\n<li><strong>float avg_std</strong>:  estimate of the standard deviation of the average</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (\nnot used)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: P_avg, P_std, P_avg_std all in atm</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierpH", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierpH", "type": "class", "doc": "<p>This class contains the definitions for Vernier standard pH\nsensor, PH-BTA.</p>\n", "bases": "RawAtoD"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierpH.__init__", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierpH.__init__", "type": "function", "doc": "<p>This init should be called first in the init section of any class\nextending this class (e.g. <code>super().__init__(Vdd)</code>). Then set\n<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units\nspecific to the sensor to <code>self.units</code>. The parameter Vdd must be\nsupplied upon initialization because the output voltage of some\nsensors depends on Vdd.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float Vdd</strong>:  the voltage supplied to the sensor by the A-to-D\nboard in case the sensor output depends on this.</li>\n</ul>\n", "signature": "(self, Vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierpH.pH", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierpH.pH", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the raw voltage</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of v_avg</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (not\nused)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: pH_avg, pH_std, pH_avg_std all in pH units</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierFlatpH", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierFlatpH", "type": "class", "doc": "<p>This class contains the definitions for Vernier flat tris-compatible pH\nsensor, FPH-BTA.</p>\n", "bases": "RawAtoD"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierFlatpH.__init__", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierFlatpH.__init__", "type": "function", "doc": "<p>This init should be called first in the init section of any class\nextending this class (e.g. <code>super().__init__(Vdd)</code>). Then set\n<code>self.name</code> and <code>self.vendor</code> to the proper values. Append units\nspecific to the sensor to <code>self.units</code>. The parameter Vdd must be\nsupplied upon initialization because the output voltage of some\nsensors depends on Vdd.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float Vdd</strong>:  the voltage supplied to the sensor by the A-to-D\nboard in case the sensor output depends on this.</li>\n</ul>\n", "signature": "(self, Vdd)", "funcdef": "def"}, {"fullname": "jupyterpidaq.Sensors.sensors.VernierFlatpH.pH", "modulename": "jupyterpidaq.Sensors.sensors", "qualname": "VernierFlatpH.pH", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>float v_avg</strong>:  average raw voltage</li>\n<li><strong>float v_std</strong>:  standard deviation of the raw voltage</li>\n<li><strong>float avg_std</strong>:  estimated standard deviation of v_avg</li>\n<li><strong>float avg_vdd</strong>:  the Vdd measured simultaneously with v_avg (not\nused)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p></p>\n</blockquote>\n\n<p>Returns: pH_avg, pH_std, pH_avg_std all in pH units</p>\n", "signature": "(self, v_avg, v_std, avg_std, avg_vdd)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();